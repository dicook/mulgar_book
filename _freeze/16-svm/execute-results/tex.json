{
  "hash": "6979227ca6c3d24eef3149ffc2591499",
  "result": {
    "markdown": "# Support vector machines\n\\index{classification methods!support vector machines (SVM)}\n\nA support vector machine (SVM) [@Va99] looks for gaps between clusters in the data, based on the extreme observations in each class. In this sense it mirrors the graphical approach described @sec-clust-graphics, in which we searched for gaps between groups. It can be viewed as similar to LDA, in that the boundary between classes is a hyperplane.  The difference between LDA and SVM is the placement of the boundary. LDA uses the means and covariance matrices of the classes to place the boundary, but SVM uses extreme observations.\n\n::: {.content-visible when-format=\"html\"}\n::: info\nThe key elements of the SVM model to extract are:\n\n- support vectors\n- separating hyperplane.\n\n:::\n:::\n\n::: {.content-visible when-format=\"pdf\"}\n\\infobox{\nThe key elements of the SVM model to extract are:\n\\begin{itemize} \\itemsep 0in\n\\item support vectors\n\\item separating hyperplane.\n\\end{itemize}\n}\n:::\n\nSVM is widely used for it's ability to fit non-linear classification models in a simple fashion using kernels in the boundary equation. We are focusing on linear methods here because it makes for a useful comparison with how the models differ from those provided by SVM. SVM tends to place the boundary between groups in a gap, if it exists. This is nice from a visual perspective because when we look at differences between classes using a tour, we naturally focus on the gaps. SVM better fits this perception than LDA. \n\nNon-linear SVM models are interesting to examine also. Mostly one would examine the boundaries between classes which can be done in the same way that is documented in the @sec-lda and @sec-trees-forests.\n\n## Components of the SVM model\n\nTo illustrate the approach, we use two simple simulated data examples. Both have only two variables, and two classes. Explaining SVM is easier when there are just two groups. In the first data set the two classes have different covariances matrices, which will cause trouble for LDA, but SVM should see the gap between the two clusters and place the separating hyperplane in the middle of the gap. In the second data set the two groups are concentric circles, with the inner one solid. A non-linear SVM should be fitted to this data, which should see circular gap between the two classes. \n\nNote that the `svm` function in the `e1071` package will automatically scale observations into the range $[0,1]$. To make it easier to examine the fitted model, it is best to scale your data first, and then fit the model.\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nlibrary(classifly)\nlibrary(e1071)\ndf1_svm <- svm(cl~., data=df1, \n                     probability=TRUE, \n                     kernel=\"linear\", \n               scale=FALSE)\ndf1_svm_e <- explore(df1_svm, df1)\n\ndf2_svm <- svm(cl~., data=df2,  \n                     probability=TRUE, \n                     kernel=\"radial\")\ndf2_svm_e <- explore(df2_svm, df2)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![SVM classifier fit overlaid on two simulated data examples: (a) groups with different variance-covariance, fitted using a linear kernel, (b) groups with non-linear separation, fitted using a radial kernel. The band of points shown as '+' mark the SVM boundary, and points marked by 'x' are the support vectors used to define the boundary. ](16-svm_files/figure-pdf/fig-svm-toy-1.pdf){#fig-svm-toy width=100%}\n:::\n:::\n\n\n\n@fig-svm-toy shows the two data sets and the important aspects of the fitted SVM model for each. The observations are represented by dots, the separating hyperplane (just a line for 2D) is represented by '+'. Where the two colours merge is the actual location of the boundary between classes. It can be seen that this is located right down the middle of the gap, for both data sets. Even though the boundary is circular for the second data set, in a transformed high-dimensional space it would be linear.\n\nSVMs use a subset of the observations to define the boundary, and these are called the support vectors. For each of the data sets these are marked with 'x'. For the linear boundary, there are nine support vectors, five in one group and four in the other. There is one interesting observation in the red group, which falls on the other side of the boundary. It is marked as a support vector, but its contribution to the fitted hyperplane is limited by a control parameter in the model fitting process. \n\nLinear SVMs can be assessed similarly to regression models. The components of the model are:\n\n1. The points that are the support vectors:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ndf1_svm$index\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  15  45 123 135 155 180 202 239 292\n```\n:::\n:::\n\n\n\n2. Their coefficients:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ndf1_svm$coefs\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            [,1]\n [1,]  0.3771240\n [2,]  0.1487726\n [3,]  1.0000000\n [4,]  1.0000000\n [5,]  1.0000000\n [6,] -0.5258966\n [7,] -1.0000000\n [8,] -1.0000000\n [9,] -1.0000000\n```\n:::\n:::\n\n\n\nwhich indicate that all but 15, 45 and 180 are actually bounded support vectors (their coefficients are bounded to magnitude 1). \n\n3. that when used with the intercept:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ndf1_svm$rho\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.3520001\n```\n:::\n:::\n\n\n\ncan be used to compute the equation of the fitted hyperplane. \n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nw = t(df1_svm$SV) %*% df1_svm$coefs\nw\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        [,1]\nx1 -1.501086\nx2 -1.356237\n```\n:::\n:::\n\n\n\nGiving the equation to be -1.5 $x_1 +$ -1.36 $x_2 +$ -0.35 $=0$, or alternatively, $x_2 =$ -1.11 $x_1 +$ -0.26.\n\nwhich can be used to generate a line to show the boundary with the data. \n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ns1 + geom_abline(intercept=df1_svm$rho/w[2],\n                 slope=-w[1]/w[2])\n```\n:::\n\n\n\n**Note that** care in scaling of data is important to get the intercept calculated exactly. We have standardised the data, and set the `scale=FALSE` parameter in the `svm` function. The slope calculation is quite robust to the data scaling.\n\n::: {.content-visible when-format=\"html\"}\n::: info\nLike LDA, a linear SVM model for two groups can be written using the equation of a hyperplane. The fitted model coefficients are then used to generate points on this plane, to examine the boundary between groups.\n:::\n:::\n\n::: {.content-visible when-format=\"pdf\"}\n\\infobox{Like LDA, a linear SVM model for two groups can be written using the equation of a hyperplane. The fitted model coefficients are then used to generate points on this plane, to examine the boundary between groups.\n}\n:::\n\n## Examining the model components in high-dimensions\n\nFor higher dimensions, the procedures are similar, with the hyperplane and support vectors being examined using a tour. Here we examine the model for differentiating male and female Chinstrap penguins. The Chinstrap penguins have a noticeable difference in size of the sexes, unlike the other two species. Working with a two-class problem is easier for explaining SVM, but multi-class calculations can also follow this approach.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nlibrary(dplyr)\nload(\"data/penguins_sub.rda\")\nchinstrap <- penguins_sub %>%\n  filter(species == \"Chinstrap\") %>%\n  select(-species) %>%\n  mutate_if(is.numeric, mulgar:::scale2)\nchinstrap_svm <- svm(sex~., data=chinstrap, \n                     kernel=\"linear\",\n                     probability=TRUE, \n                     scale=FALSE)\nchinstrap_svm_e <- explore(chinstrap_svm, chinstrap)\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n\n::: {.content-visible when-format=\"html\"}\n::: {#fig-p-svm-html layout-ncol=2}\n\n![Support vectors](gifs/chinstrap_svs.gif){#fig-chinstrap_svs fig-alt=\"FIX ME\" width=300}\n\n![SVM boundary](gifs/chinstrap_svm.gif){#fig-chinstrap_svm fig-alt=\"FIX ME\" width=300}\n\nSVM model for distinguishing the sexes of the Chinstrap penguins. The separating hyperplane is 3D, and separates primarily on variables `bl` and `bd`, as seen because these two axes extend out from the plane when it is seen on its side, separating the two groups.\n:::\n:::\n\n::: {.content-visible when-format=\"pdf\"}\n::: {#fig-p-svm-pdf layout-ncol=2}\n\n![Support vectors](images/chinstrap_svs.png){#fig-chinstrap_svs fig-alt=\"FIX ME\" width=200}\n\n![SVM boundary](images/chinstrap_svm.png){#fig-chinstrap_svm fig-alt=\"FIX ME\" width=200}\n\nSVM model for distinguishing the sexes of the Chinstrap penguins. The separating hyperplane is 3D, and separates primarily on variables `bl` and `bd`, as seen because these two axes extend out from the plane when it is seen on its side, separating the two groups.\n:::\n:::\n\nExamining the hyperplane in a grand tour display (@fig-p-svm-pdf) indicates that two of the variables, `bl` and `bd`, are important for separating the two classes. We can check this interpretation using the radial tour. Using the components from the model, the coefficients of the hyperplane are: \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nt(chinstrap_svm$SV) %*% chinstrap_svm$coefs\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         [,1]\nbl -0.9102439\nbd -1.1073475\nfl -0.5223364\nbm -0.2846370\n```\n:::\n:::\n\n\n\nThis supports the observation that `bl` and `bd` are most important, because they have the largest magnitudes. We can use this vector to set the starting point for radial tour. It needs to be normalised. A randomly generated second vector orthonormal to this one can be added to make a 2D projection from which to see the boundary.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nset.seed(1022)\nprj1 <- mulgar::norm_vec(t(chinstrap_svm$SV) %*%\n                           chinstrap_svm$coefs)\nprj2 <- basis_random(4, 1)\nprj <- orthonormalise(cbind(prj1, prj2))\nprj\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         [,1]        [,2]\nbl -0.5865081 -0.06412875\nbd -0.7135101  0.51192498\nfl -0.3365631 -0.77713899\nbm -0.1834035 -0.36038216\n```\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\n\n::: {.content-visible when-format=\"html\"}\n::: {#fig-chinstrap-radial layout-ncol=2}\n\n![bl](gifs/chinstrap_rad_bl.gif){#fig-chinstrap-radial-bl}\n\n![bd](gifs/chinstrap_rad_bd.gif){#fig-chinstrap-radial-bd}\n\n![fl](gifs/chinstrap_rad_fl.gif){#fig-chinstrap-radial-fl}\n\n![bm](gifs/chinstrap_rad_bm.gif){#fig-chinstrap-radial-bm}\n\nExploring the importance of the four variables to the separating hyperplane using a radial tour where the contribution of each variable is reduced to 0, and then increased to it's original value. You can see that `bl` and `bd` contribute most to the plane, because when they are removed the plane is no longer on it side marking the boundary. Variables `fl` and `bm` contribute a small amount to the separating hyperplane, but it is possible that these two could be removed without affecting the strength of the separation between the sexes. \n:::\n:::\n\n::: {.content-visible when-format=\"html\"}\n::: insight\nWhen we use the radial tour to examine how the different variables contribute to the separating hyperplane between the sexes, we learn that `bl` and `bd` are the most important variables. Very little contribution comes from `fl` and `bm`.\n:::\n:::\n\n::: {.content-visible when-format=\"pdf\"}\n\\insightbox{When we use the radial tour to examine how the different variables contribute to the separating hyperplane between the sexes, we learn that `bl` and `bd` are the most important variables. Very little contribution comes from {\\textsf fl} and {\\textsf bm}.}\n:::\n\n<!-- include Distance-weighted discrimination, eg kerndwd -->\n\n\n## Exercises {-}\n\n1. Generate a small subset from the `bushfire` data: we keep the variables `log_dist_cfa`, `log_dist_road` and `cause`, and we select only observations where `cause` is either lightning or arson. Fit a linear SVM model to separate the two classes and show the decision boundary together with the data. Compare to the boundary obtained by LDA and argue how the two models place the separating hyperplane in different ways.\n2. We extend this into a multivariate setting by also including `amaxt180` and `amaxt720` as predictors. Fit a linear SVM model and calculate the hyperplane to judge which of these variables are important.\n3. Calculate the decision boundary and look at it with a radial tour to see the effect from including individual predictors in a projection. Also explore what happens when rotating out multiple variables together. What can you learn from this?\n4. From the `sketches_train` data select all observations of class banana or boomerang For this subset use PCA to find the first 5 PCs. Fit two SVM models: once with linear kernel and once with radial kernel and default value for the gamma parameter. Compare the number of missclassified observations in the training data for the two models.\n5. Compute the model predictions and compare the decision boundaries between the linear and radial SVM using a slice tour. Does the shape match what you expect given the respective kernel function?\n6. SVM models are defined for separating two classes, but and ensemble of such models can be used when we want to distinguish more than two classes. Look up the documentation of the `svm` function to learn how this works, then fit an SVM model to separate the three penguin species. In this case we primarily use the model predictions to investigate the decision boundaries, you can use `explore` together with the slice tour to do this. You can use different kernels and compare the resulting decision boundaries.\n\n\n\n\n::: {.cell}\n\n:::\n",
    "supporting": [
      "16-svm_files/figure-pdf"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}