{
  "hash": "aaea2c5a4a66af562fde6c2282f5dd87",
  "result": {
    "engine": "knitr",
    "markdown": "# Technical details {#sec-notation}\n\n## Notation conventions and R objects \n\nThe data can be considered to be a matrix of numbers with the columns corresponding to variables, and the rows correspond to observations. It can be helpful to write this in mathematical notation, like:\n\n\\begin{eqnarray*}\nX_{n\\times p} =\n[X_1~X_2~\\dots~X_p]_{n\\times p} = \\left[ \\begin{array}{cccc}\nX_{11} & X_{12} & \\dots & X_{1p} \\\\\nX_{21} & X_{22} & \\dots & X_{2p}\\\\\n\\vdots & \\vdots &  & \\vdots \\\\\nX_{n1} & X_{n2} & \\dots & X_{np} \\end{array} \\right]_{n\\times p}\n\\end{eqnarray*}\n\nwhere $X$ indicates the $n\\times p$ data matrix, $X_j$ indicates variable $j, j=1, \\dots, p$ and $X_{ij}$ indicates the value of the $j^{th}$ variable for the $i^{th}$ observation. (It can be confusing to distinguish whether one is referring to the observation or a variable, because $X_i$ is used to indicate observation. In descriptions where it is unclear we will use $X_{i.}$ to indicate observation/row and $X_{.j}$ to indicate variable/column. Also this will usually accompanied by qualifying words such as **observation** or **variable**.)\n\n\\index{data!matrix}\n\n::: {.content-visible when-format=\"html\"}\n::: info\nHaving notation is helpful for concise explanations of different methods, to explain how data is scaled, processed and projected for various tasks, and how different quantities are calculated from the data. \n:::\n:::\n\n::: {.content-visible when-format=\"pdf\"}\n\n\\infobox{Having notation is helpful for concise explanations of different methods, to explain how data is scaled, processed and projected for various tasks, and how different quantities are calculated from the data. }\n\n:::\n\nWhen there is a response variable(s), it is common to consider $X$ to be the predictors, and use $Y$ to indicate the response variable(s). $Y$ could be a matrix, also, and would be $n\\times q$, where commonly $q=1$. $Y$ could be numeric or categorical, and this would change how it is handled with visualisation.\n\nTo make a low-dimensional projection (shadow) of the data onto $d$ dimensions ($d < p$), we need an orthonormal basis:\n\n\\begin{eqnarray*}\nA_{p\\times d} = \\left[ \\begin{array}{cccc}\nA_{11} & A_{12} & \\dots & A_{1d} \\\\\nA_{21} & A_{22} & \\dots & A_{2d}\\\\\n\\vdots & \\vdots &  & \\vdots \\\\\nA_{p1} & A_{p2} & \\dots & A_{pd} \\end{array} \\right]_{p\\times d}\n\\end{eqnarray*}\n\n\\index{orthonormal}\n\\index{projection basis}\n\n$A$ should be an orthonormal matrix, which means that the $\\sum_{j=1}^p A_{jk}^2=1, k=1, \\dots, d$ (columns represent vectors of length 1) and $\\sum_{j=1}^p A_{jk}A_{jl}=0, k,l=1, \\dots, d; k\\neq l$ (columns represent vectors that are orthogonal to each other). In matrix notation, this can be written as $A^{\\top}A = I_d$.\n\\index{data!projection}\n\nThen the projected data is written as:\n\n\\begin{eqnarray*}\nY_{n\\times d} = XA = \\left[ \\begin{array}{cccc}\ny_{11} & y_{12} & \\dots & y_{1d} \\\\\ny_{21} & y_{22} & \\dots & y_{2d}\\\\\n\\vdots & \\vdots &  & \\vdots \\\\\ny_{n1} & y_{n2} & \\dots & y_{nd} \\end{array} \\right]_{n\\times d}\n\\end{eqnarray*}\n\nwhere $y_{ij} = \\sum_{k=1}^p X_{ik}A_{kj}$. Note that we are using $Y$ as the projected data here, as well as it possibly being used for a response variable. Where necessary, this will be clarified with words in the text, when notation is used in explanations later.\n\nWhen using R, if we only have the data corresponding to $X$ it makes sense to use a `matrix` object. However, if the response variable is included and it is categorical, then we might use a `data.frame` or a `tibble` which can accommodate non-numerical values. Then to work with the data, we can use the base R methods:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nX <- matrix(c(1.1, 1.3, 1.4, 1.2, \n              2.7, 2.6, 2.4, 2.5, \n              3.5, 3.4, 3.2, 3.6), \n            ncol=4, byrow=TRUE)\nX\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]  1.1  1.3  1.4  1.2\n[2,]  2.7  2.6  2.4  2.5\n[3,]  3.5  3.4  3.2  3.6\n```\n\n\n:::\n:::\n\n\n\n\n\n\nwhich is a data matrix with $n=3, p=4$ and to extract a column (variable):\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nX[,2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.3 2.6 3.4\n```\n\n\n:::\n:::\n\n\n\n\n\n\nor a row (observation):\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nX[2,]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.7 2.6 2.4 2.5\n```\n\n\n:::\n:::\n\n\n\n\n\n\nor an individual cell (value):\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nX[3,2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.4\n```\n\n\n:::\n:::\n\n\n\n\n\n\nTo make the data projection we need an orthonormal matrix:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nA <- matrix(c(0.707,0.707,0,0,0,0,0.707,0.707), ncol=2, byrow=FALSE)\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      [,1]  [,2]\n[1,] 0.707 0.000\n[2,] 0.707 0.000\n[3,] 0.000 0.707\n[4,] 0.000 0.707\n```\n\n\n:::\n:::\n\n\n\n\n\n\nYou can check that it is orthonormal by\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nsum(A[,1]^2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.999698\n```\n\n\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\nsum(A[,1]*A[,2])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n:::\n\n\n\n\n\n\nand compute the projected data using matrix multiplication:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nX %*% A\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       [,1]   [,2]\n[1,] 1.6968 1.8382\n[2,] 3.7471 3.4643\n[3,] 4.8783 4.8076\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThe magical number `0.707` used above and to create the projection in @fig-explain-1D-html arises from normalising a vector with equal contributions from each variable, `(1, 1)`. Dividing by `sqrt(2)` gives `(0.707, 0.707)`.\n\n\n::: {.content-visible when-format=\"html\"}\n::: info\nThe notation convention used throughout the book is:\n\n `n =` number of observations<br>\n `p =` number of variables, dimension of data<br>\n `d =` dimension of the projection<br>\n `g =` number of groups, in classification<br>\n `X =` data matrix\n:::\n:::\n\n::: {.content-visible when-format=\"pdf\"}\n\n\\infobox{The notation convention used throughout the book is:\n\\begin{itemize}\n\\item n = number of observations\n\\item p = number of variables, dimension of data\n\\item d = dimension of the projection\n\\item g = number of groups, in classification\n\\item X = data matrix\n\\end{itemize}\n}\n:::\n\n## Mechanics of tours\n\n### Different ways to choose target bases\n\nAlthough there are a variety of different tour types, they are (almost) all composed of three core building blocks: a set of target projection bases, a method for interpolating between them and the method to display the projected data. The manner that the target planes are chosen primarily determines the type of tour. @fig-tour-types-html illustrates three main tour types: grand, guided and radial. The appendix has a list of the many others. \n\n::: {.content-visible when-format=\"html\"}\n::: {.info-box}\nTours are composed from three elements:\n- a set of target projection bases\n- an interpolation method\n- the method to display the projected data\n:::\n:::\n\n::: {.content-visible when-format=\"pdf\"}\n\n\\infobox{\nTours are composed from three elements:\n\\begin{itemize}\n\\item a set of target projection bases\n\\item an interpolation method\n\\item the method to display the projected data\n\\end{itemize}\n}\n:::\n\nThe original tour was called the *grand tour* [@As85]. In a grand tour, the target bases are chosen randomly from all possible projections. The reason to use a grand tour is to get an overview of the data quickly - it is possible to discover relationships between variables that were not pre-conceived. The particular grand tour available in the `tourr` package also has the feature that all projections are equally likely to be viewed, and it efficiently covers the space of all projections. The tour in the `langevitour` [@langevitour] software is similar to a grand tour but uses a different dynamic to choose the tour path, based on jostling particles. It doesn't need to do interpolation because changes are incremental. \n\n\\index{tour!grand}\n\\index{tour!guided}\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\nBecause space gets large as dimension increases, the wait for seeing interesting structure in projections when using a grand tour can be long. So if you have an idea of the types of structure that would be interesting to observe using a *guided tour* [@CBCH95] may help. A guided tour chooses target bases according to some function describing interesting, and the tour path follows an optimisation of this function. For example, the `LDA` index [@LCKL05] is a function that describes the separation between known classes in a projection, and is defined as follows: \n\n\\begin{eqnarray*}\nI_{\\rm LDA}(A) = 1- \\frac{|A'WA|}{|A'(W+B)A|}\n\\end{eqnarray*}\n\nwhere $B = \\sum_{i=1}^g\nn_i(\\bar{y}_{i.}-\\bar{y}_{..})(\\bar{y}_{i.}-\\bar{y}_{..})',\nW=\\sum_{i=1}^g\\sum_{j=1}^{n_i}\n(y_{ij}-\\bar{y}_{i.})(y_{ij}-\\bar{y}_{i.})'$ are the\nbetween- and within-group sum of squares matrices in a linear\ndiscriminant analysis, with $g=$number of groups, and $n_i, i=1, ....g$ is the number of cases in each group. \n\nThe *radial tour* [@radial-tour] provides a way to assess the importance of any variable or combination of variables. The target basis is chosen by zeroing out a variable (or multiple variables) and the interpolation runs from the initial projection to the target and back to the initial. If the structure observed in the initial plot doesn't change much when the variable(s) is removed, then the variable is not important. This is often best combined with the guided tour, where the radial tour would start from the best projection (as done in @fig-tour-types-html c), the most structured projection, and each of the variables can be tested for their importance in producing the structure.\n\nEach of these tour types can be run in the `tourr` package by setting the `tour_path` parameter of the `animate_XXX()` functions. The paths of projection bases can also be generated and saved to be used later with the `save_history()` function. This is the manner with which to save a particular data projection, or to generate sequences of projections to pass to external software. \n\n::: {.content-visible when-format=\"html\"}\n::: {#fig-tour-types-html  layout=\"[[33, 33, 33]]\"}\n\n![grand tour](gifs/penguins_cl_grand.gif)\n\n![guided tour](gifs/penguins_cl_guided.gif)\n\n![radial](gifs/penguins_cl_radial.gif)\n\nThree main tour types for examining multivariate data: (a) grand tour for obtaining an overview, (b) guided tour to explore for particular structure, (c) radial tour to assess the importance of a variable. The guided tour does show the separations between the three groups better, but will miss unexpected features like the several anomalies. The radial tour shows that `fl` is not contributing much to the separation of the Gentoo (red) penguins from the others.\n:::\n:::\n\n\n::: {.content-visible when-format=\"pdf\"}\n\n::: {#fig-tour-types-pdf layout=\"[[100]]\"}\n\n![Data projected into three target projection bases from a grand tour](images/p_grand3.png)\n\n![Data projected into three target projection bases from a guided tour](images/p_guided3.png)\n\n![Data projected into three target projection bases from a radial tour](images/p_radial3.png)\n\nWith the grand tour (a) each target plane is randomly selected, to show as many possible projections as possible and obtain an overview of the data. A tour guided by the LDA index (b) steers towards projections where the species are most separated. However, the guided tour might miss something unexpected, like the anomaly (yellow) seen in the third grand tour frame (a). The radial tour (c) rotates a variable (here \\texttt{fl}) out of the projection and back in to assess the impact on the structure. It can be seen that removing the contribution of \\texttt{fl} makes only a small difference to the separation. {{< fa play-circle >}}\n:::\n\n:::\n\n::: {#fig-interpolation layout=\"[[100]]\"}\n![](images/interpolation.png)\n\nTwo different types of interpolation to a target: (a) geodesic plane-to-plane, (b) basis-to-basis using Givens rotations. The geodesic interpolation follows the shortest paths between planes. Givens respects the orientation of the basis when plotting or calculating projection pursuit indexes. Both methods maintain orthonormality of the bases for each step. \n:::\n\n### Interpolating between targets\n\nInterpolating from the current basis to the target basis is most commonly achieved using geodesic interpolation. This type of interpolation (described in @BCAH05) has especially important properties: (1) it is plane-to-plane so follows the shortest path, and (2) maintains orthonormality of the basis at each step when $d>1$. The plane-to-plane movement operates like video stabilisation, by removing the within-plane spin, so you can focus on structure without distracting movement. However, when using the guided tour if the index is not rotationally invariant, for example, if based on correlation or splines, it can be important respect a particular orientation. For this rare situation, using Givens interpolation, available in the `woylier` package [@R-woylier] can be helpful. @fig-interpolation illustrates the difference.\n\n### Displaying the projected data\n\nBased on the dimension of the projection basis there are natural ways to display the projected data. If $d=2$ it is most common that we would use a scatterplot, as shown in (as done in @fig-tour-types-html. \n\nIf $d=1$ there are many choices of display - histogram, density plot, dotplot, boxplot - any method commonly used to display univariate continuous data (see `animate_dist()`). If $d=1$ but a second (set of) variable(s) is available, such as a time index, a categorical variable index (`animate_idx()`), or spatial coordinates (`animate_image()`), then the display might reserve one axis for the projected data and another for the additional variables. @fig-displays shows two different display choices for $d=1$, a histogram of the projected data (a) and an ordered dotplot of an index created by combining values of several ranking variables. In each display the box with horizontal lines at the bottom represents the projection coefficients. In (a) there are six variables contributing to the projection, four with negative coefficients, which reveals some bimodality and a potential anomaly in this data. In (b), nine ranking variables on the liveability of 10 US cities are combined to give an overall rank for each city. This combination is a projection, and a tour is used to assess how the city ranks would change if the combination of these measures changed. That is, the use case, is how robust is the ranking to small changes in its construction.\n\nWhen $d>2$, even though it primarily academic, some possible choices are to use stereo to simulate 3D, scatterplot matrices or parallel coordinates. \n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\n::: {#fig-displays layout=\"[[63,37]]\"}\n\n\n![histogram](images/display-dist2.png)\n\n![dotplot](images/display-idx.png)\n\nDifferent choices for displaying projected data: (a) histogram, (b) ordered dotplot. In each case the projected data is 1D. In the histogram, the lines at the bottom of the display correspond to the projection basis. For the ordered dotplot each point corresponds to a US city, which has been measured on several criteria such as housing, climate, crime, and education. The lines at the bottom correspond the coefficients for each of these ratings in the projection basis.\n:::\n\nAdjustments to the display are useful for some problems. The crowding problem where points concentrate as dimension increases can be alleviated with a transformation of the projected data documented in @sagetour and available with the `animate_sage()` function. When the data is particularly dense, for example, simulated data filling out a full $p$-dimensional cube from a fitted model generated to understand the fit, it can be useful to use slicing [@slicetour]. Slicing will fade out observations beyond a given distance from the centre of the data, relative to the projection. @fig-slicing-html illustrates the slice display available using the `animate_slice()` function.\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\n::: {.content-visible when-format=\"html\"}\n::: {#fig-slicing-html layout=\"[[50, 50]]\"}\n\n![projection](gifs/torus_proj.gif)\n\n![slice](gifs/torus_slice.gif)\n\nSlicing can cut through high density is useful to find hollowness in high-dimensional data, or understand limitations of fitted models. Here points on the surface of a 3D torus are shown using (a) projections, and (b) slices. The slicing reveals the hollowness of this data with the circular cuts to the donut shape.\n:::\n:::\n\n::: {.content-visible when-format=\"pdf\"}\n::: {#fig-slicing-pdf  layout=\"[[50, 50]]\"}\n\n![projection](images/torus_proj.png)\n\n![slice](images/torus_slice.png)\n\nSlicing can cut through high density is useful to find hollowness in high-dimensional data, or understand limitations of fitted models. Here points on the surface of a 3D torus are shown using (a) projections, and (b) slices. The slicing reveals the hollowness of this data with the circular cuts to the donut shape. {{< fa play-circle >}}\n:::\n:::\n\nIt can also be useful to add layers to the data, such as summary statistics, labels for selected observations, or connecting points with lines to represent model fits. @fig-adornments-html illustrates two use cases. In (a) labels for specific players are shown when examining player statistics in the `aflw` data. All three were named best players in the 2021 AFLW season, Bowers and Davey were equal best and fairest, and Vescio was awarded best goal kicker. All three have quite different player statistics profiles. The play of Bowers and Davey differs in the number of handballs and kicks -  Davey tends to distribute the ball with handballs, while Bowers tends to kick. In (b) the lines indicate constraints. This is compositional data where each row adds to 1. It is the `Fireworks` data from the `compositions` [@R-compositions] package, and measures the mixtures of five different ingredients. We can see that it is relatively equal mixtures because all are very centred within the constraints. We can also see points banding into stripes, suggesting that there are just a small number of firework recipes. \n\n\\index{data!aflw}\n\\index{data!fireworks}\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\n::: {.content-visible when-format=\"html\"}\n::: {#fig-adornments-html layout=\"[[50, 50]]\"}\n\n![labelling](gifs/aflw_labelled.gif)\n\n![constraints](gifs/fireworks.gif)\n\nIt is sometimes useful to overlay additional information, such as labels for a few points (a) or representing constraints (b). The labels in (a) correspond to players that won awards in the 2021 AFLW season. The lines in (b) correspond to constraints - this is compositional data where each 5D observation is constrained to sum to 1.\n:::\n:::\n\n::: {.content-visible when-format=\"pdf\"}\n::: {#fig-adornments-pdf layout=\"[[50, 50]]\"}\n\n![labelling](images/aflw_labelled.png)\n\n![constraints](images/fireworks.png)\n\nIt is sometimes useful to overlay additional information, such as labels for a few points (a) or representing constraints (b). The labels in (a) correspond to players that won awards in the 2021 AFLW season. The lines in (b) correspond to constraints - this is compositional data where each 5D observation is constrained to sum to 1. {{< fa play-circle >}}\n:::\n:::\n\nIt is often asked why isn't the data display using solid shapes, or provide depth cues with point size or colour. But the nature of high-dimensions is that comprehensive research on lighting models and perspective conducted for 3D graphics, does not extend to more than 3D. For example, a light source, like a lamp, is a point object, and in 4D the shadows would be 3D. A surface in 4D is 3D. So the choice of using points to represent objects, and lines to indicate geometric features is because these are meaningful in any dimension.  \n\n## Exercises {-}\n\n1. Generate a matrix $A$ with $p=5$ (rows) and $d=2$ (columns), where each value is randomly drawn from a standard normal distribution. Extract the element at row 3 and column 1.\n2. We will interpret $A$ as an orthonormal basis and therefore it needs to be checked for orthonormality, and if it fails, then to be orthonormalised. Use the function `tourr::is_orthonormal` to explicitly check that each column is normalised and that the two columns are orthogonal. If they are not, then use `tourr::orthonormalise` to make them so. For the fixed version of $A$, which dimensions contribute most to the projection, horizontally and vertically?\n3. Use matrix multiplication to calculate the projection of the `mulgar::clusters` data onto the 2D plane defined by $A$. Make a scatterplot of the projected data. Can you identify clustering in this view?\n4. Use `save_history()` to generate a grand tour path for the `mulgar::clusters` data, with three target planes. Extract and report the second target basis, and plot the resulting data. \n5. Using the saved path, generate the interpolation between the target planes, using `interpolate()`. How many bases are in the tour path? Plot the first four in set of planes, and explain what is happening.\nSave tour path, extract basis and plot data\n6. Repeat `save_history()` but use a holes index guided tour. Plot the final projection. Does the guided tour find the three clusters? Which of the variables have the largest contributions to the differences between groups?\n7. Repeat `save_history()` using a radial tour, starting from the best projection basis from the guided tour, and exploring the contribution of `x1` (`mvar=1`). Why should the length of the path be set to three? Why is the last basis the same as the first? Examine the second target basis, and explain how it is different from the first basis.\n8. Run the tours from in 4-7 using the `animate_xy()`. You can use the `planned_tour` method, but it is more interesting to simply re-generate using the different `tour_path` methods. It is interesting to examine the importance of `x5` and `x4` to the clustering seen in the best projection from the guided tour.\n9. Examine tours of 1D projections of the `mulgar::clusters` data, using density or histogram rendering. Can the three clusters be seen with 1D projections?\n10. Explore the use of the slice tour on these geometric objects, that can be simulated using `geozoo`:\n\na. Roman Surface, generated by \n\n`rs <- geozoo::roman.surface()$points |> scale() |> as.data.frame()`\n  \nb. solid 4D sphere, generated by \n\n`s_solid <- geozoo::sphere.solid.random(4, 2000)$points |> as.data.frame()`\n\nc. hollow 4D sphere, generated by \n\n`s_hollow <- geozoo::sphere.hollow(4, 2000)$points |> as.data.frame()`\n\nUse both regular tours, and the slice tours on each. What does the slice tour allow us to see in the Roman Surface? What is the difference between the solid and hollow spheres?\n\n::: {.content-hidden when-format=\"pdf\"}\n::: {.hidden}\n## Solutions to exercises\n:::\n:::\n \n  \n\n\n\n\n\n::: {.cell}\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}