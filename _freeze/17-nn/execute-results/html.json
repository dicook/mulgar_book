{
  "hash": "3c79cb7ae6fbe9d39730143a508022ad",
  "result": {
    "engine": "knitr",
    "markdown": "# Neural networks and deep learning\n\\index{classification!neural networks}\n\nNeural networks (NN) can be considered to be nested additive (or even ensemble) models where explanatory variables are combined, and transformed through an activation function like a logistic. These transformed combinations are added recursively to yield class predictions. They are considered to be black box models, but there is a growing demand for interpretability. Although interpretability is possible, it can be unappealing to understand a complex model constructed to tackle a difficult classification task. Nevertheless, this is the motivation for the explanation of visualisation for NN models in this chapter. \n\nIn the simplest form, we might write the equation for a NN as\n\n$$\n\\hat{y} = f(x) = a_0+\\sum_{h=1}^{s}\nw_{0h}\\phi(a_h+\\sum_{i=1}^{p} w_{ih}x_i)\n$$\nwhere $s$ indicates the number of nodes in the hidden (middle layer), and $\\phi$ is a choice of activation function. In a simple situation where $p=3$, $s=2$, and linear output layer, the model could be written as:\n\n$$\n\\begin{aligned}\n\\hat{y} = a_0+ & w_{01}\\phi(a_1+w_{11}x_1+w_{21}x_2+w_{31}x_3) +\\\\\n & w_{02}\\phi(a_2+w_{12}x_1+w_{22}x_2+w_{32}x_3)\n\\end{aligned}\n$$\nwhich is a combination of two (linear) models, each of which could be examined for their role in making predictions. \n\nIn practice, a model may have many nodes, and several hidden layers, a variety of activation functions, and regularisation modifications. One should keep in mind the principle of parsimony is important when applying NNs, because it is tempting to make an overly complex, and thus over-parameterised, construction.  Fitting NNs is still problematic. One would hope that fitting produces a stable result, whatever the starting seed the same parameter estimates are returned. However, this is not the case, and different, sometimes radically different, results are routinely obtained after each attempted fit [@wickham2015]. \n\nFor these examples we use the software `keras` [@keras] following the installation and tutorial details at [https://tensorflow.rstudio.com/tutorials/](https://tensorflow.rstudio.com/tutorials/). Because it is an interface to python it can be tricky to install. If this is a problem, the example code should be possible to convert to use `nnet` [@VR02] or `neuralnet` [@neuralnet]. We will use the penguins data to illustrate the fitting, because it makes it easier to understand the procedures and the fit. However, a NN is like using a jackhammer instead of a trowel to plant a seedling, more complicated than necessary to build a good classification model for this data.\n\n## Setting up the model \n\\index{classification!ANN architecture}\n\nA first step is to decide how many nodes the NN architecture should have, and what activation function should be used. To make these decisions, ideally you already have some knowledge of the shapes of class clusters. For the penguins classification, we have seen that it contains three elliptically shaped clusters of roughly the same size. This suggests two nodes in the hidden layer would be sufficient to separate three clusters (@fig-nn-diagram). Because the shapes of the clusters are convex, using linear activation (\"relu\") will also be sufficient. The model specification is as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(keras)\ntensorflow::set_random_seed(211)\n\n# Define model\np_nn_model <- keras_model_sequential()\np_nn_model %>% \n  layer_dense(units = 2, activation = 'relu', \n              input_shape = 4) %>% \n  layer_dense(units = 3, activation = 'softmax')\np_nn_model %>% summary\n\nloss_fn <- loss_sparse_categorical_crossentropy(\n  from_logits = TRUE)\n\np_nn_model %>% compile(\n  optimizer = \"adam\",\n  loss      = loss_fn,\n  metrics   = c('accuracy')\n)\n```\n:::\n\n\nNote that `tensorflow::set_random_seed(211)` sets the seed for the model fitting so that we can obtain the same result to discuss later. It needs to be set before the model is defined in the code. The model will also be saved in order to diagnose and make predictions. \n\n![Network architecture for the model on the penguins data. The round nodes indicate original or transformed variables, and each arrow connecting these is represented as one of the weights $w_{ih}$ in the definition. The boxes indicate the additive constant entering the nodes, and the corresponding arrows represent the terms $a_h$. ](images/nn-diagram.png){#fig-nn-diagram align=\"center\"}\n\n\n::: {.cell}\n\n:::\n\n\n## Checking the training/test split\n\\index{classification!training/test split}\n\nSplitting the data into training and test is an essential way to protect against overfitting, for most classifiers, but especially so for the copiously parameterised NNs. The model specified for the penguins data with only two nodes is unlikely to be overfitted, but it is nevertheless good practice to use a training set for building and a test set for evaluation. \n\n@fig-p-split-html shows the tour being used to examine the split into training and test samples for the penguins data. Using random sampling, particularly stratified by group, should result the two sets being very similar, as can be seen here. It does happen that several observations in the test set are on the extremes of their class cluster, so it could be that the model makes errors in the neighbourhoods of these points.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Split the data intro training and testing\nlibrary(ggthemes)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(rsample)\nlibrary(ggbeeswarm)\n\nload(\"data/penguins_sub.rda\") # from mulgar book\n\nset.seed(821)\np_split <- penguins_sub %>% \n  select(bl:species) %>%\n  initial_split(prop = 2/3, \n                strata=species)\np_train <- training(p_split)\np_test <- testing(p_split)\n\n# Check training and test split\np_split_check <- bind_rows(\n  bind_cols(p_train, type = \"train\"), \n  bind_cols(p_test, type = \"test\")) %>%\n  mutate(type = factor(type))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Code to run tours\"}\nanimate_xy(p_split_check[,1:4], \n           col=p_split_check$species,\n           pch=p_split_check$type)\nanimate_xy(p_split_check[,1:4], \n           guided_tour(lda_pp(p_split_check$species)),\n           col=p_split_check$species,\n           pch=p_split_check$type)\nrender_gif(p_split_check[,1:4],\n           grand_tour(),\n           display_xy( \n             col=p_split_check$species, \n             pch=p_split_check$type,\n             cex=1.5,\n             axes=\"bottomleft\"), \n           gif_file=\"gifs/p_split.gif\",\n           frames=500,\n           loop=FALSE\n)\nrender_gif(p_split_check[,1:4],\n           guided_tour(lda_pp(p_split_check$species)),\n           display_xy( \n             col=p_split_check$species, \n             pch=p_split_check$type,\n             cex=1.5,\n             axes=\"bottomleft\"), \n           gif_file=\"gifs/p_split_guided.gif\",\n           frames=500,\n           loop=FALSE\n)\n```\n:::\n\n\n::: {.content-visible when-format=\"html\"}\n::: {#fig-p-split-html layout-ncol=2}\n\n![Grand tour](gifs/p_split.gif){#fig-split-grand fig-alt=\"FIX ME\" width=300}\n\n![Guided tour](gifs/p_split_guided.gif){#fig-split-guided fig-alt=\"FIX ME\" width=300}\n\nEvaluating the training/test split, where we expect that the two samples should roughly match. There are a few observations in the test set that are on the outer edges of the clusters, which will likely result in the model making an error in these regions. However, the two samples roughly match.\n:::\n:::\n\n::: {.content-visible when-format=\"pdf\"}\n::: {#fig-p-split-pdf layout-ncol=2}\n\n![Grand tour](images/p_split.png){#fig-split-grand fig-alt=\"FIX ME\" width=220}\n\n![Guided tour](images/p_split_guided.png){#fig-split-guided fig-alt=\"FIX ME\" width=220}\n\nEvaluating the training/test split, where we expect that the two samples should roughly match. There are a few observations in the test set that are on the outer edges of the clusters, which will likely result in the model making an error in these regions. However, the two samples roughly match.\n:::\n:::\n\n## Fit the model\n\\index{classification!Fitting a NN}\n\nThe data needs to be specially formatted for the model fitted using `keras`. The explanatory variables need to be provided as a `matrix`, and the categorical response needs to be separate, and specified as a `numeric` variable, beginning with 0. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Data needs to be matrix, and response needs to be numeric\np_train_x <- p_train %>%\n  select(bl:bm) %>%\n  as.matrix()\np_train_y <- p_train %>% pull(species) %>% as.numeric() \np_train_y <- p_train_y-1 # Needs to be 0, 1, 2\np_test_x <- p_test %>%\n  select(bl:bm) %>%\n  as.matrix()\np_test_y <- p_test %>% pull(species) %>% as.numeric() \np_test_y <- p_test_y-1 # Needs to be 0, 1, 2\n```\n:::\n\n\nThe specified model is reasonably simple, four input variables, two nodes in the hidden layer and a three column binary matrix for output. This corresponds to 5+5+3+3+3=19 parameters. \n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\nModel: \"sequential\"\n________________________________________________________________________________\n Layer (type)                       Output Shape                    Param #     \n================================================================================\n dense_1 (Dense)                    (None, 2)                       10          \n dense (Dense)                      (None, 3)                       9           \n================================================================================\nTotal params: 19 (76.00 Byte)\nTrainable params: 19 (76.00 Byte)\nNon-trainable params: 0 (0.00 Byte)\n________________________________________________________________________________\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Fit model\np_nn_fit <- p_nn_model %>% keras::fit(\n  x = p_train_x, \n  y = p_train_y,\n  epochs = 200,\n  verbose = 0\n)\n```\n:::\n\n::: {.cell}\n\n:::\n\n\nBecause we set the random number seed we will get the same fit each time the code provided here is run. However, if the model is re-fit without setting the seed, you will see that there is a surprising amount of variability in the fits. Setting `epochs = 200` helps to usually get a good fit. One expects that `keras` is reasonably stable so one would not expect the huge array of fits as observed in @wickham2015 using `nnet`. That this can happen with the simple model used here reinforces the notion that fitting of NN models is fiddly, and great care needs to be taken to validate and diagnose the fit. \n\n::: {.content-visible when-format=\"html\"}\n::: info\nFitting NN models is fiddly, and very different fitted models can result from restarts, parameter choices, and architecture. \n:::\n:::\n\n::: {.content-visible when-format=\"pdf\"}\n\\infobox{Fitting NN models is fiddly, and very different fitted models can result from restarts, parameter choices, and architecture.  \n}\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nlibrary(keras)\nlibrary(ggplot2)\nlibrary(colorspace)\n\n# load fitted model\np_nn_model <- load_model_tf(\"data/penguins_cnn\")\n```\n:::\n\n\nThe fitted model that we have chosen as the final one has reasonably small loss and high accuracy. Plots of loss and accuracy across epochs showing the change during  fitting can be plotted, but we don't show them here, because they are generally not very interesting.\n\n\n::: {.cell}\n\n```{.r .cell-code}\np_nn_model %>% evaluate(p_test_x, p_test_y, verbose = 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     loss  accuracy \n0.2563850 0.9553571 \n```\n\n\n:::\n:::\n\n\nThe model object can be saved for later use with:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsave_model_tf(p_nn_model, \"data/penguins_cnn\")\n```\n:::\n\n\n## Extracting model components\n\\index{classification!hidden layers}\n\n::: {.content-visible when-format=\"html\"}\n::: info\nView the individual node models to understand how they combine to produce the overall model.\n:::\n:::\n\n::: {.content-visible when-format=\"pdf\"}\n\\infobox{View the individual node models to understand how they combine to produce the overall model.\n}\n:::\n\nBecause nodes in the hidden layers of NNs are themselves (relatively simple regression) models, it can be interesting to examine these to understand how the model is making it's predictions. Although it's rarely easy, most software will allow the coefficients for the models at these nodes to be extracted. With the penguins NN model there are two nodes, so we can extract the coefficients and plot the resulting two linear combinations to examine the separation between classes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extract hidden layer model weights\np_nn_wgts <- keras::get_weights(p_nn_model, trainable=TRUE)\np_nn_wgts \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n           [,1]        [,2]\n[1,]  0.6216676  1.33304155\n[2,]  0.1851478 -0.01596385\n[3,] -0.1680396 -0.30432791\n[4,] -0.8867414 -0.36627045\n\n[[2]]\n[1]  0.12708087 -0.09466381\n\n[[3]]\n           [,1]     [,2]       [,3]\n[1,] -0.1646167 1.527644 -1.9215064\n[2,] -0.7547278 1.555889  0.3210194\n\n[[4]]\n[1]  0.4554813 -0.9371488  0.3577386\n```\n\n\n:::\n:::\n\n\nThe linear coefficients for the first node in the model are 0.62, 0.19, -0.17, -0.89, and the second node in the model are 1.33, -0.02, -0.3, -0.37. We can use these like we used the linear discriminants in LDA to make a 2D view of the data, where the model is separating the three species. The constants 0.13, -0.09 are not important for this. They are only useful for drawing the location of the boundaries between classes produced by the model.\n\nThese two sets of model coefficients provide linear combinations of the original variables. Together, they define a plane on which the data is projected to view the classification produced by the model. Ideally, though this plane should be defined using an orthonormal basis otherwise the shape of the data distribution might be warped. So we orthonormalise this matrix before computing the data projection.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Orthonormalise the weights to make 2D projection\np_nn_wgts_on <- tourr::orthonormalise(p_nn_wgts[[1]])\np_nn_wgts_on\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           [,1]       [,2]\n[1,]  0.5593355  0.7969849\n[2,]  0.1665838 -0.2145664\n[3,] -0.1511909 -0.1541475\n[4,] -0.7978314  0.5431528\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Hidden layer\np_train_m <- p_train %>%\n  mutate(nn1 = as.matrix(p_train[,1:4]) %*%\n           as.matrix(p_nn_wgts_on[,1], ncol=1),\n         nn2 = as.matrix(p_train[,1:4]) %*%\n           matrix(p_nn_wgts_on[,2], ncol=1))\n\n# Now add the test points on.\np_test_m <- p_test %>%\n  mutate(nn1 = as.matrix(p_test[,1:4]) %*%\n           as.matrix(p_nn_wgts_on[,1], ncol=1),\n         nn2 = as.matrix(p_test[,1:4]) %*%\n           matrix(p_nn_wgts_on[,2], ncol=1))\np_train_m <- p_train_m %>%\n  mutate(set = \"train\")\np_test_m <- p_test_m %>%\n  mutate(set = \"test\")\np_all_m <- bind_rows(p_train_m, p_test_m)\nggplot(p_all_m, aes(x=nn1, y=nn2, \n                     colour=species, shape=set)) + \n  geom_point() +\n  scale_colour_discrete_divergingx(palette=\"Zissou 1\") +\n  scale_shape_manual(values=c(16, 1)) +\n  theme_minimal() +\n  theme(aspect.ratio=1)\n```\n\n::: {.cell-output-display}\n![Plot of the data in the linear combinations from the two nodes in the hidden layer. The three species are clearly different, although with some overlap between all three. A main issue to notice is that there isn't a big gap between Gentoo and the other species, which we know is there based on our data exploration done in other chapters. This suggests this fitted model is sub-optimal.](17-nn_files/figure-html/fig-hidden-layer-1.png){#fig-hidden-layer fig-alt='FIXME' width=80%}\n:::\n:::\n\n\n@fig-hidden-layer shows the data projected into the plane determined by the two linear combinations of the two nodes in the hidden layer. Training and test sets are indicated by empty and solid circles. The three species are clearly different but there is some overlap or confusion for a few penguins. The most interesting aspect to learn is that there is no big gap between the Gentoo and other species, which we know exists in the data. The model has not found this gap, and thus is likely to unfortunately and erroneously confuse some Gentoo penguins, particularly with Adelie.\n\nWhat we have shown here is a process to use the models at the nodes of the hidden layer to produce a reduced dimensional space where the classes are best separated, at least as determined by the model. The process will work in higher dimensions also. \n\nWhen there are more nodes in the hidden layer than the number of original variables it means that the space is extended to achieve useful classifications that need more complicated non-linear boundaries. The extra nodes describe the non-linearity. @wickham2015 provides a good illustration of this in 2D. The process of examining each of the node models can be useful for understanding this non-linear separation, also in high dimensions.\n\n## Examining predictive probabilities\n\\index{classification!predictive probabilities}\n\nWhen the predictive probabilities are returned by a model, as is done by this NN, we can use a ternary diagram for three class problems, or high-dimensional simplex when there are more classes to examine the strength of the classification. This done in the same way that was used for the votes matrix from a random forest in @sec-votes. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Predict training and test set\np_train_pred <- p_nn_model %>% \n  predict(p_train_x, verbose = 0)\np_train_pred_cat <- levels(p_train$species)[\n  apply(p_train_pred, 1,\n        which.max)]\np_train_pred_cat <- factor(\n  p_train_pred_cat,\n  levels=levels(p_train$species))\ntable(p_train$species, p_train_pred_cat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           p_train_pred_cat\n            Adelie Chinstrap Gentoo\n  Adelie        92         4      1\n  Chinstrap      0        45      0\n  Gentoo         1         0     78\n```\n\n\n:::\n\n```{.r .cell-code}\np_test_pred <- p_nn_model %>% \n  predict(p_test_x, verbose = 0)\np_test_pred_cat <- levels(p_test$species)[\n  apply(p_test_pred, 1, \n        which.max)]\np_test_pred_cat <- factor(\n  p_test_pred_cat,\n  levels=levels(p_test$species))\ntable(p_test$species, p_test_pred_cat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           p_test_pred_cat\n            Adelie Chinstrap Gentoo\n  Adelie        45         3      1\n  Chinstrap      0        23      0\n  Gentoo         1         0     39\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# Set up the data to make the ternary diagram\n# Join data sets\ncolnames(p_train_pred) <- c(\"Adelie\", \"Chinstrap\", \"Gentoo\")\ncolnames(p_test_pred) <- c(\"Adelie\", \"Chinstrap\", \"Gentoo\")\np_train_pred <- as_tibble(p_train_pred)\np_train_m <- p_train_m %>%\n  mutate(pspecies = p_train_pred_cat) %>%\n  bind_cols(p_train_pred) %>%\n  mutate(set = \"train\")\np_test_pred <- as_tibble(p_test_pred)\np_test_m <- p_test_m %>%\n  mutate(pspecies = p_test_pred_cat) %>%\n  bind_cols(p_test_pred) %>%\n  mutate(set = \"test\")\np_all_m <- bind_rows(p_train_m, p_test_m)\n\n# Add simplex to make ternary\nlibrary(geozoo)\nproj <- t(geozoo::f_helmert(3)[-1,])\np_nn_v_p <- as.matrix(p_all_m[,c(\"Adelie\", \"Chinstrap\", \"Gentoo\")]) %*% proj\ncolnames(p_nn_v_p) <- c(\"x1\", \"x2\")\np_nn_v_p <- p_nn_v_p %>%\n  as.data.frame() %>%\n  mutate(species = p_all_m$species,\n         set = p_all_m$set)\n\nsimp <- geozoo::simplex(p=2)\nsp <- data.frame(cbind(simp$points), simp$points[c(2,3,1),])\ncolnames(sp) <- c(\"x1\", \"x2\", \"x3\", \"x4\")\nsp$species = sort(unique(penguins_sub$species))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# Plot it\nggplot() +\n  geom_segment(data=sp, aes(x=x1, y=x2, xend=x3, yend=x4)) +\n  geom_text(data=sp, aes(x=x1, y=x2, label=species),\n            nudge_x=c(-0.1, 0.15, 0),\n            nudge_y=c(0.05, 0.05, -0.05)) +\n  geom_point(data=p_nn_v_p, aes(x=x1, y=x2, \n                                colour=species,\n                                shape=set), \n             size=2, alpha=0.5) +\n  scale_color_discrete_divergingx(palette=\"Zissou 1\") +\n  scale_shape_manual(values=c(19, 1)) +\n  theme_map() +\n  theme(aspect.ratio=1, legend.position = \"right\")\n```\n\n::: {.cell-output-display}\n![Ternary diagram for the three groups of the predictive probabilities of both training ans test sets. From what we already know about the penguins data this fit is not good. Both Chinstrap and Gentoo penguins are confused with Adelie, or at risk of it. Gentoo is very well-separated from the other two species when several variables are used, and this fitted model is blind to it. One useful finding is that there is little difference between training and test sets, so the model has not been over-fitted.](17-nn_files/figure-html/unnamed-chunk-17-1.png){width=70%}\n:::\n:::\n\n\n\n::: {.content-visible when-format=\"html\"}\n::: info\nIf the training and test sets look similar when plotted in the model space then the model is not suffering from over-fitting.\n:::\n:::\n\n::: {.content-visible when-format=\"pdf\"}\n\\infobox{If the training and test sets look similar when plotted in the model space then the model is not suffering from over-fitting. \n}\n:::\n\n## Local explanations\n\\index{classification!local explanations}\n\\index{classification!XAI}\n\nIt especially important to be able to interpret or explain a model, even more so when the model is complex or black-box'y. A good resource for learning about the range of methods is @iml. Local explanations provide some information about variables that are important for making the prediction for a particular observation. The method that we use here is Shapley value, as computed using the `kernelshap` package [@kernelshap]. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Explanations\n# https://www.r-bloggers.com/2022/08/kernel-shap/\nlibrary(kernelshap)\nlibrary(shapviz)\np_explain <- kernelshap(\n    p_nn_model,\n    p_train_x, \n    bg_X = p_train_x,\n    verbose = FALSE\n  )\np_exp_sv <- shapviz(p_explain)\nsave(p_exp_sv, file=\"data/p_exp_sv.rda\")\n```\n:::\n\n\nA Shapley value for an observation indicates how the variable contributes to the model prediction for that observation, relative to other variables. It is an average, computed from the change in prediction when all combinations of presence or absence of other variables. In the computation, for each combination, the prediction is computed by substituting absent variables with their average value, like one might do when imputing missing values. \n\n@fig-shapley-pcp shows the Shapley values for Gentoo observations (both training and test sets) in the penguins data, as a parallel coordinate plot. The values for the single misclassified Gentoo penguin (in the training set) is coloured orange. Overall, the Shapley values don't vary much on `bl`, `bd` and `fl` but they do on `bm`. The effect of other variables is seems to be only important for `bm`. \n\nFor the misclassified penguin, the effect of `bm` for all combinations of other variables leads to a decline in predicted value, thus less confidence in it being a Gentoo. In contrast, for this same penguin when considering the effect of `bl` the predicted value increases on average. \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nload(\"data/p_exp_sv.rda\")\np_exp_gentoo <- p_exp_sv$Class_3$S\np_exp_gentoo <- p_exp_gentoo %>%\n  as_tibble() %>%\n  mutate(species = p_train$species,\n         pspecies = p_train_pred_cat,\n  ) %>%\n  mutate(error = ifelse(species == pspecies, 0, 1))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\np_exp_gentoo %>%\n  filter(species == \"Gentoo\") %>%\n  pivot_longer(bl:bm, names_to=\"var\", values_to=\"shap\") %>%\n  mutate(var = factor(var, levels=c(\"bl\", \"bd\", \"fl\", \"bm\"))) %>%\n  ggplot(aes(x=var, y=shap, colour=factor(error))) +\n  geom_quasirandom(alpha=0.8) +\n  scale_colour_discrete_divergingx(palette=\"Geyser\") +\n  #facet_wrap(~var) +\n  xlab(\"\") + ylab(\"SHAP\") +\n  theme_minimal() + \n  theme(legend.position = \"none\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nlibrary(ggpcp)\np_exp_gentoo %>%\n  filter(species == \"Gentoo\") %>%\n  pcp_select(1:4) %>%\n  ggplot(aes_pcp()) +\n    geom_pcp_axes() + \n    geom_pcp_boxes(fill=\"grey80\") + \n    geom_pcp(aes(colour = factor(error)), \n             linewidth = 2, alpha=0.3) +\n  scale_colour_discrete_divergingx(palette=\"Geyser\") +\n  xlab(\"\") + ylab(\"SHAP\") +\n  theme_minimal() + \n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![SHAP values focused on Gentoo class, for each variable. The one misclassified penguin (orange) has a much lower value for body mass, suggesting that this variable is used differently for the prediction than for other penguins.](17-nn_files/figure-html/fig-shapley-pcp-1.png){#fig-shapley-pcp fig-alt='FIXME' width=80%}\n:::\n:::\n\n\nIf we examine the data [@fig-penguins-bl-bm-bd] the explanation makes some sense. The misclassified penguin has an unusually small value on `bm`. That the SHAP value for `bm` was quite different pointed to this being a potential issue with the model, particularly for this penguin. This penguin's prediction is negatively impacted by `bm` being in the model.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nlibrary(patchwork)\n# Check position on bm\nshap_proj <- p_exp_gentoo %>%\n  filter(species == \"Gentoo\", error == 1) %>%\n  select(bl:bm)\nshap_proj <- as.matrix(shap_proj/sqrt(sum(shap_proj^2)))\np_exp_gentoo_proj <- p_exp_gentoo %>%\n  rename(shap_bl = bl, \n         shap_bd = bd,\n         shap_fl = fl, \n         shap_bm = bm) %>%\n  bind_cols(as_tibble(p_train_x)) %>%\n  mutate(shap1 = shap_proj[1]*bl+\n           shap_proj[2]*bd+\n           shap_proj[3]*fl+\n           shap_proj[4]*bm)\nsp1 <- ggplot(p_exp_gentoo_proj, aes(x=bm, y=bl, \n             colour=species, \n             shape=factor(1-error))) +\n    geom_point(alpha=0.8) +\n  scale_colour_discrete_divergingx(palette=\"Zissou 1\") +\n  scale_shape_manual(\"error\", values=c(19, 1)) +\n  theme_minimal() + \n  theme(aspect.ratio=1, legend.position=\"bottom\")\nsp2 <- ggplot(p_exp_gentoo_proj, aes(x=bm, y=shap1, \n             colour=species, \n             shape=factor(1-error))) +\n    geom_point(alpha=0.8) +\n  scale_colour_discrete_divergingx(palette=\"Zissou 1\") +\n  scale_shape_manual(\"error\", values=c(19, 1)) +\n  ylab(\"SHAP\") +\n  theme_minimal() + \n  theme(aspect.ratio=1, legend.position=\"bottom\")\nsp2 <- ggplot(p_exp_gentoo_proj, aes(x=shap1, \n             fill=species, colour=species)) +\n  geom_density(alpha=0.5) +\n  geom_vline(xintercept = p_exp_gentoo_proj$shap1[\n    p_exp_gentoo_proj$species==\"Gentoo\" &\n    p_exp_gentoo_proj$error==1], colour=\"black\") +\n  scale_fill_discrete_divergingx(palette=\"Zissou 1\") +\n  scale_colour_discrete_divergingx(palette=\"Zissou 1\") +\n  theme_minimal() + \n  theme(aspect.ratio=1, legend.position=\"bottom\")\nsp2 <- ggplot(p_exp_gentoo_proj, aes(x=bm, y=bd, \n             colour=species, \n             shape=factor(1-error))) +\n    geom_point(alpha=0.8) +\n  scale_colour_discrete_divergingx(palette=\"Zissou 1\") +\n  scale_shape_manual(\"error\", values=c(19, 1)) +\n  theme_minimal() + \n  theme(aspect.ratio=1, legend.position=\"bottom\")\nsp1 + sp2 + plot_layout(ncol=2, guides = \"collect\") &\n  theme(legend.position=\"bottom\",\n        legend.direction=\"vertical\")\n```\n\n::: {.cell-output-display}\n![Plots of the data to help understand what the SHAP values indicate. The misclassified Gentoo penguin has an unusually low body mass value which makes it appear to be more like an Adelie penguin, particularly when considered in relation to it's bill length.](17-nn_files/figure-html/fig-penguins-bl-bm-bd-1.png){#fig-penguins-bl-bm-bd fig-alt='FIXME' width=100%}\n:::\n:::\n\n\n## Examining boundaries\n\n<!-- Check against LDA, suspect that `bm` is used too much in CNN model.-->\n@fig-penguins-lda-nn shows the boundaries for this NN model along with those of the LDA model. \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# Generate grid over explanatory variables\np_grid <- tibble(\n  bl = runif(10000, min(penguins_sub$bl), max(penguins_sub$bl)),\n  bd = runif(10000, min(penguins_sub$bd), max(penguins_sub$bd)),\n  fl = runif(10000, min(penguins_sub$fl), max(penguins_sub$fl)),\n  bm = runif(10000, min(penguins_sub$bm), max(penguins_sub$bm))\n)\n# Predict grid\np_grid_pred <- p_nn_model %>%\n  predict(as.matrix(p_grid), verbose=0)\np_grid_pred_cat <- levels(p_train$species)[apply(p_grid_pred, 1, which.max)]\np_grid_pred_cat <- factor(p_grid_pred_cat,\n                          levels=levels(p_train$species))\n\n# Project into weights from the two nodes\np_grid_proj <- as.matrix(p_grid) %*% p_nn_wgts_on\ncolnames(p_grid_proj) <- c(\"nn1\", \"nn2\")\np_grid_proj <- p_grid_proj %>% \n  as_tibble() %>%\n  mutate(species = p_grid_pred_cat)\n\n# Plot\nggplot(p_grid_proj, aes(x=nn1, y=nn2, \n                     colour=species)) + \n  geom_point(alpha=0.5) +\n  geom_point(data=p_all_m, aes(x=nn1, \n                               y=nn2, \n                               shape=species),\n             inherit.aes = FALSE) +\n  scale_colour_discrete_divergingx(palette=\"Zissou 1\") +\n  scale_shape_manual(values=c(1, 2, 3)) +\n  theme_minimal() +\n  theme(aspect.ratio=1, \n        legend.position = \"bottom\",\n        legend.title = element_blank())\n```\n:::\n\n\n\n::: {.content-visible when-format=\"html\"}\n\n::: {#fig-penguins-lda-nn-html layout-ncol=2}\n\n![LDA model](gifs/penguins_lda_boundaries.gif){#fig-lda-boundary fig-alt=\"FIX ME\" width=300}\n\n![NN model](gifs/penguins_nn_boundaries.gif){#fig-tree-boundary fig-alt=\"FIX ME\" width=300}\n\nComparison of the boundaries produced by the LDA (a) and the NN (b) model, using a slice tour. \n:::\n:::\n\n::: {#fig-penguins-lda-nn layout-ncol=2}\n\n![LDA model](images/fig-lda-2D-boundaries-1.png){#fig-lda-boundary2 fig-alt=\"FIX ME\" width=200}\n\n![NN model](images/penguins-nn-boundaries-1.png){#fig-nn-boundary fig-alt=\"FIX ME\" width=290}\n\nComparison of the boundaries produced by the LDA (a) and the NN (b) model, using a slice tour. \n:::\n\n\\index{tour!slice} \n\n## Application to a large dataset\n\nTo see how these methods apply in the setting where we have a large number of variables, observations and classes we will look at a neural network that predicts the category for the fashion MNIST data. The code for designing and fitting the model is following the tutorial available from https://tensorflow.rstudio.com/tutorials/keras/classification and you can find additional information there. Below we only replicate the steps needed to build the model from scratch. We also note that a similar investigation was presented in @li2020visualizing, with a focus on investigating the model at different epochs during the training.\n\\index{data!fashion MNIST}\n\nThe first step is to download and prepare the data. Here we scale the observations to range between zero and one, and we define the label names.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(keras)\n\n# download the data\nfashion_mnist <- dataset_fashion_mnist()\n\n# split into input variables and response\nc(train_images, train_labels) %<-% fashion_mnist$train\nc(test_images, test_labels) %<-% fashion_mnist$test\n\n# for interpretation we also define the category names\nclass_names = c('T-shirt/top',\n                'Trouser',\n                'Pullover',\n                'Dress',\n                'Coat',\n                'Sandal',\n                'Shirt',\n                'Sneaker',\n                'Bag',\n                'Ankle boot')\n\n# rescaling to the range (0,1)\ntrain_images <- train_images / 255\ntest_images <- test_images / 255\n```\n:::\n\n\nIn the next step we define the neural network and train the model. Note that because we have many observations, even a very simple structure returns a good model. And because this example is well-known, we do not need to tune the model or check the validation accuracy.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# defining the model\nmodel_fashion_mnist <- keras_model_sequential()\nmodel_fashion_mnist %>%\n  # flatten the image data into a long vector\n  layer_flatten(input_shape = c(28, 28)) %>%\n  # hidden layer with 128 units\n  layer_dense(units = 128, activation = 'relu') %>%\n  # output layer for 10 categories\n  layer_dense(units = 10, activation = 'softmax')\n\nmodel_fashion_mnist %>% compile(\n  optimizer = 'adam',\n  loss = 'sparse_categorical_crossentropy',\n  metrics = c('accuracy')\n)\n\n# fitting the model, if we did not know the model yet we\n# would add a validation split to diagnose the training\nmodel_fashion_mnist %>% fit(train_images,\n              train_labels,\n              epochs = 5)\nsave_model_tf(model_fashion_mnist, \"data/fashion_nn\")\n```\n:::\n\n\nWe have defined a flat neural network with a single hidden layer with 128 nodes. To investigate the model we can start by comparing the activations to the original input data distribution. Since both the input space and the space of activations is large, and they are of different dimensionality, we will first use principal component analysis. This simplifies the analysis, and in general we do not need the original pixel or hidden node information for the interpretation here. The comparison is using the test-subset of the data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# get the fitted model\nmodel_fashion_mnist <- load_model_tf(\"data/fashion_nn\")\n# observed response labels in the test set\ntest_tags <- factor(class_names[test_labels + 1],\n                    levels = class_names)\n\n# calculate activation for the hidden layer, this can be done\n# within the keras framework\nactivations_model_fashion <- keras_model(\n  inputs = model_fashion_mnist$input,\n  outputs = model_fashion_mnist$layers[[2]]$output\n)\nactivations_fashion <- predict(\n  activations_model_fashion,\n  test_images, verbose = 0)\n\n# PCA for activations\nactivations_pca <- prcomp(activations_fashion)\nactivations_pc <- as.data.frame(activations_pca$x)\n\n# PCA on the original data\n# we first need to flatten the image input\ntest_images_flat <- test_images\ndim(test_images_flat) <- c(nrow(test_images_flat), 784)\nimages_pca <- prcomp(as.data.frame(test_images_flat))\nimages_pc <- as.data.frame(images_pca$x)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Code to run tours\"}\np2 <- ggplot(activations_pc,\n       aes(PC1, PC2, color = test_tags)) +\n  geom_point(size = 0.1) +\n  ggtitle(\"Activations\") +\n  scale_color_discrete_qualitative(palette = \"Dynamic\") +\n  theme_bw() +\n  theme(legend.position = \"none\", aspect.ratio = 1)\n\np1 <- ggplot(images_pc,\n       aes(PC1, PC2, color = test_tags)) +\n  geom_point(size = 0.1) +\n  ggtitle(\"Input space\") +\n  scale_color_discrete_qualitative(palette = \"Dynamic\") +\n  theme_bw() +\n  theme(legend.position = \"none\", aspect.ratio = 1)\n\nlegend_labels <- cowplot::get_legend(\n  p1 + \n    guides(color = guide_legend(nrow = 1)) +\n    theme(legend.position = \"bottom\",\n          legend.title = element_blank()) +\n    guides(color = guide_legend(override.aes = list(size = 1))) \n)\n# hide plotting code\ncowplot::plot_grid(cowplot::plot_grid(p1, p2), legend_labels,\n                   rel_heights = c(1, .3), nrow = 2)\n```\n\n::: {.cell-output-display}\n![](17-nn_files/figure-html/unnamed-chunk-27-1.png){width=672}\n:::\n:::\n\n\nLooking only at the first two principal components we note some clear differences from the transformation in the hidden layer. The observations seem to be more evenly spread in the input space, while in the activations space we notice grouping along specific directions. In particular the category \"Bag\" appears to be most different from all other classes, and the non-linear transformation in the activations space shows that they are clearly different from the shoe categories, while in the input space we could note some overlap in the linear projection. To better identify differences between other groups we will use the tour on the first five principal components.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Code to run tours\"}\nanimate_xy(images_pc[,1:5], col = test_tags,\n        cex=0.2, palette = \"Dynamic\")\nanimate_xy(activations_pc[,1:5], col = test_tags,\n        cex=0.2, palette = \"Dynamic\")\n\nrender_gif(images_pc[,1:5],\n           grand_tour(),\n           display_xy( \n             col=test_tags, \n             cex=0.2,\n             palette = \"Dynamic\",\n             axes=\"bottomleft\"), \n           gif_file=\"gifs/fashion_images_gt.gif\",\n           frames=500,\n           loop=FALSE\n)\nrender_gif(activations_pc[,1:5],\n           grand_tour(),\n           display_xy( \n             col=test_tags, \n             cex=0.2,\n             palette = \"Dynamic\",\n             axes=\"bottomleft\"), \n           gif_file=\"gifs/fashion_activations_gt.gif\",\n           frames=500,\n           loop=FALSE\n)\n```\n:::\n\n\n::: {.content-visible when-format=\"html\"}\n::: {#fig-fashion-gt-html layout-ncol=2}\n\n![Input space](gifs/fashion_images_gt.gif){#fig-fashion-input fig-alt=\"FIX ME\" width=200}\n\n![Activations](gifs/fashion_activations_gt.gif){#fig-fashion-activation fig-alt=\"FIX ME\" width=200}\n\nComparison of the test observations in the first five principal components of the input space (left) and in the hidden layer activations (right). The activation function results in more clearly defined grouping of the different classes.\n:::\n:::\n\n\n::: {.content-visible when-format=\"pdf\"}\n::: {#fig-p-split-pdf layout-ncol=2}\n\n![Input space](images/fashion_images_gt_36.png){#fig-fashion-input fig-alt=\"FIX ME\" width=200}\n\n![Activations](images/fashion_activation_gt_126.png){#fig-fashion-activation fig-alt=\"FIX ME\" width=200}\n\nComparison of the test observations in the first five principal components of the input space (left) and in the hidden layer activations (right). The activation function results in more clearly defined grouping of the different classes.\n:::\n:::\n\nAs with the first two principal components we get a much more spread out distribution in the original space. Nevertheless we can see differences between the classes, and that some groups are varying along specific directions in that space. Overall the activations space shows tighter clusters as expected after including the ReLU activation function, but the picture is not as neat as the first two principal components would suggest. While certain groups appear very compact even in this larger subspace, others vary quite a bit within part of the space. For example we can clearly see the \"Bag\" observations as different from all other images, but also notice that there is a large variation within this class along certain directions.\n\nFinally we will investigate the model performance through the missclassifications and uncertainty between classes. We start with the error matrix for the test observations. To fit the error matrix we use the numeric labels, the ordering is as defined above for the labels.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfashion_test_pred <- predict(model_fashion_mnist,\n                             test_images, verbose = 0)\nfashion_test_pred_cat <- levels(test_tags)[\n  apply(fashion_test_pred, 1,\n        which.max)]\npredicted <- factor(\n  fashion_test_pred_cat,\n  levels=levels(test_tags)) %>%\n  as.numeric() - 1\nobserved <- as.numeric(test_tags) -1\ntable(observed, predicted)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        predicted\nobserved    0    1    2    3    4    5    6    7    8    9\n       0  128    0   84  719   10    0   51    7    1    0\n       1    0   42   15  941    0    0    0    2    0    0\n       2    6    0  824   38  121    0    3    8    0    0\n       3    1    0   14  976    8    0    1    0    0    0\n       4    1    0  205  181  605    0    0    8    0    0\n       5    1    0    0    2    0   77    0  902    1   17\n       6   24    0  231  282  405    0   44   12    2    0\n       7    0    0    0    0    0    0    0 1000    0    0\n       8   17    1   78  102   49    0    5  730   16    2\n       9    0    0    0    2    0    0    0  947    0   51\n```\n\n\n:::\n:::\n\n\nFrom this we see that the model mainly confuses certain categories with each other, and within expected groups (e.g. different types of shoes can be confused with each other, or different types of shirts). We can further investigate this by visualizing the full probability matrix for the test observations, to see which categories the model is uncertain about.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Code to visualize probabilities\"}\n# getting the probabilities from the output layer\nfashion_test_pred <- predict(model_fashion_mnist,\n                             test_images, verbose = 0)\n\n# copying this from RF fake tree vote matrix\nproj <- t(geozoo::f_helmert(10)[-1,])\nf_nn_v_p <- as.matrix(fashion_test_pred) %*% proj\ncolnames(f_nn_v_p) <- c(\"x1\", \"x2\", \"x3\", \"x4\", \"x5\", \"x6\", \"x7\", \"x8\", \"x9\")\n\nf_nn_v_p <- f_nn_v_p %>%\n  as.data.frame() %>%\n  mutate(class = test_tags)\n\nsimp <- geozoo::simplex(p=9)\nsp <- data.frame(simp$points)\ncolnames(sp) <- c(\"x1\", \"x2\", \"x3\", \"x4\", \"x5\", \"x6\", \"x7\", \"x8\", \"x9\")\nsp$class = \"\"\nf_nn_v_p_s <- bind_rows(sp, f_nn_v_p) %>%\n  mutate(class = ifelse(class %in% c(\"T-shirt/top\",\n                                     \"Pullover\",\n                                     \"Shirt\",\n                                     \"Coat\"), class, \"Other\")) %>%\n  mutate(class = factor(class, levels=c(\"Other\",\n                                        \"T-shirt/top\",\n                                        \"Pullover\",\n                                        \"Shirt\",\n                                        \"Coat\"))) \n# nicely shows confusion between certain classes is common\nanimate_xy(f_nn_v_p_s[,1:9], col = f_nn_v_p_s$class, \n           axes = \"off\", pch = \".\",\n           edges = as.matrix(simp$edges),\n           edges.width = 0.05,\n           palette = \"Lajolla\")\n```\n:::\n\n\nFor this data using explainers like SHAP is not so interesting, since the individual pixel contribution to a prediction are typically not of interest. With image classification a next step might be to further investigate which part of the image is important for a prediction, and this can be visualized as a heat map placed over the original image. This is especially interesting in the case of difficult or missclassified images. This however is beyond the scope of this book.\n\n\n<!--\nThis chapter will likely include:\n\n- Models at nodes or epochs \n- Predictions (like vote matrix) for training and test. It provides a visual guide to overfitting.\n- Classification boundaries comparison with other methods\n- Explainability and interpretability\n\n(This paper https://distill.pub/2020/grand-tour/ has good examples)\n\nNOTE: Results might vary with different knits \n\nReferences keras/tensorflow book, tidymodels, interpretable machine learning, and removing the blindfold\n\n\nOutline for chapter:\n\n- Penguins data\n    - Setting up with the NN with keras\n    - Splitting training and test, checking\n    - Specifying model, choices of layers\n    - Making predictions\n    - Extracting weights\n    - Building your diagnostic data set\n    - Examine predictive probabilities with simplex\n    - Examining the nodes - like the discriminant space when its 2\n    - Misclassifications\n    - \n\nBushfires\n    - Model fitting when regularisation needed\n    - Overfitting\n    \nSketches as an example  \n-->\n\n## Exercises {-}\n\n1. The problem with the NN model fitted to the penguins is that the Gentoo are poorly classified, when they should be perfectly predictable due to the big gap between class clusters. Re-fit the NN to the penguins data, to find a better model that appropriately perfectly predicts Gentoo penguins. Support this by plotting the model (using the hidden layer), and the predictive probabilities as a ternary plot. Do the SHAP values also support that `bd` plays a stronger role in your best model? (`bd` is the main variable for distinguishing Gentoo's from the other species, particularly when used with `fl` or `bl`.)\n2. For the fashion MNIST data we have seen that certain categories are more likely to be confused with each other. Select a subset of the data including only the categories Ankle boot, Sneaker and Sandal and see if you can reproduce the analysis of the penguins data in this chapter with this subset.\n3. XXX fake trees, can we think about the number of nodes and make it work with a simple NN similar to penguins data?\n4. The sketches data could also be considered a classic image classification problem, and we have seen that we can get a reasonable accuracy with a random forest model. Because we only have a smaller number of observations (compared to the fashion MNIST data) when fitting a neural network we need to be very careful not to overfit the training data. Try fitting a flat neural network (similar to what we did for the fashion MNIST data) and check the test accuracy of the model.\n5. Challenge: try to design a more accurate neural network for the sketches data. Here you can investigate using a convolutional neural network in combination with data augmentation. In addition, using batch normalization should improve the model performance.\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n",
    "supporting": [
      "17-nn_files/figure-html"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}