{
  "hash": "0b08642c75f77b6c7855b352f4b25b00",
  "result": {
    "markdown": "# Neural networks and deep learning\n\\index{classification!neural networks}\n\nNeural networks can be considered to be nested additive (or even ensemble) models where explanatory variables are combined, and transformed through an activation function like a logistic, added to other combinations of explanatory variables recursively to yield class predictions. They are considered to be the black box models, but there is a growing demand for interpretability. Although interpretability is possible, it can be unappealing to understand a complex model constructed to tackle a difficult classification task. Nevertheless, this is the motivation for the explanation of visualisation for neural network models in this chapter. \n\nIn the simplest form, we might write the equation for a neural network as\n\n$$\n\\hat{y} = f(x) = \\phi(a_0+\\sum_{h=1}^{s}\nw_{0h}\\phi(a_h+\\sum_{i=1}^{p} w_{ih}x_i))\n$$\nwhere $s$ indicates the number of nodes in the hidden (middle layer), and $\\phi$ is a choice of activation function. In a simple situation where $p=3$, $s=2$, and linear output layer, the model could be written as:\n\n$$\n\\begin{aligned}\n\\hat{y} = a_0+ & w_{01}\\phi(a_1+w_{11}x_1+w_{21}x_2+w_{31}x_3) +\\\\\n & w_{02}\\phi(a_2+w_{12}x_1+w_{22}x_2+w_{32}x_3)\n\\end{aligned}\n$$\nwhich is a combination of two (linear) models, each of which could be examined for their role in making predictions. \n\nIn practice, a model may have many nodes, and several hidden layers, a variety of activation functions, and regularisation modifications. One should keep in mind the principle of parsimony is important when applying neural networks, because it is tempting to make an overly complex, and thus over-parameterised, construction.  Fitting neural networks is still problematic. One would hope that fitting produces a stable result, whatever the starting seed the same parameter estimates are returned. However, this is not the case, and different, sometimes radically different, results are routinely obtained after each attempted fit [@wickham2015]. \n\nFor these examples we use the software `keras` [@keras] following the installation and tutorial details at [https://tensorflow.rstudio.com/tutorials/](https://tensorflow.rstudio.com/tutorials/). Because it is an interface to python it can be tricky to install. If this is a problem, the example code should be possible to convert to use `nnet` [@VR02] or `neuralnet` [@neuralnet]. We will use the penguins data to illustrate the fitting, because it makes it easier to understand the procedures and the fit. However, a neural network is like using a jackhammer instead of a trowel to plant a seedling, more complicated than necessary to build a good classification model for this data.\n\n## Setting up the model \n\\index{classification!ANN architecture}\n\nA first step is to decide how many nodes the neural network architecture should have, and and what activation function should be used. To make these decisions, ideally you already has some knowledge of the shapes of class clusters. For the penguins classification, we have seen that it contains three elliptically shaped clusters of roughly the same size. This suggests two nodes in the hidden layer would be sufficient to separate three clusters (@fig-nn-diagram). Because the shapes of the clusters are convex, using linear activation (\"relu\") will also be sufficient. The model specification is as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(keras)\ntensorflow::set_random_seed(211)\n\n# Define model\np_nn_model <- keras_model_sequential()\np_nn_model %>% \n  layer_dense(units = 2, activation = 'relu', \n              input_shape = 4) %>% \n  layer_dense(units = 3, activation = 'softmax')\np_nn_model %>% summary\n\nloss_fn <- loss_sparse_categorical_crossentropy(\n  from_logits = TRUE)\n\np_nn_model %>% compile(\n  optimizer = \"adam\",\n  loss      = loss_fn,\n  metrics   = c('accuracy')\n)\n```\n:::\n\n\nNote that `tensorflow::set_random_seed(211)` sets the seed for the model fitting so that we can obtain the same result to discuss later. It needs to be set before the model is defined in the code. The model will also saved in order to diagnose and make predictions. \n\n![Network architecture for the model on the penguins data.](images/nn-diagram.png){#fig-nn-diagram align=\"center\"}\n\n\n::: {.cell}\n\n:::\n\n\n## Checking the training/test split\n\\index{classification!training/test split}\n\nSplitting the data into training and test is an essential way to protect against overfitting, for most classifiers, but especially so for the copiously parameterised neural networks. The model specified for the penguins data with only two nodes is unlikely to be overfitted, but it is nevertheless good practice to use a training set for building and a test set for evaluation. \n\n@fig-p-split-html shows the tour being used to examine the split into training and test samples for the penguins data. Using random sampling, particularly stratified by group, should result the two sets being very similar, as can be seen here. It does happen that several observations in the test set are on the extremes of their class cluster, so it could be that the model makes errors in the neighbourhoods of these points.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Split the data intro training and testing\nlibrary(ggthemes)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(rsample)\nlibrary(ggbeeswarm)\n\nload(\"data/penguins_sub.rda\") # from mulgar book\n\nset.seed(821)\np_split <- penguins_sub %>% \n  select(bl:species) %>%\n  initial_split(prop = 2/3, \n                strata=species)\np_train <- training(p_split)\np_test <- testing(p_split)\n\n# Check training and test split\np_split_check <- bind_rows(\n  bind_cols(p_train, type = \"train\"), \n  bind_cols(p_test, type = \"test\")) %>%\n  mutate(type = factor(type))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Code to run tours\"}\nanimate_xy(p_split_check[,1:4], \n           col=p_split_check$species,\n           pch=p_split_check$type)\nanimate_xy(p_split_check[,1:4], \n           guided_tour(lda_pp(p_split_check$species)),\n           col=p_split_check$species,\n           pch=p_split_check$type)\nrender_gif(p_split_check[,1:4],\n           grand_tour(),\n           display_xy( \n             col=p_split_check$species, \n             pch=p_split_check$type,\n             cex=1.5,\n             axes=\"bottomleft\"), \n           gif_file=\"gifs/p_split.gif\",\n           frames=500,\n           loop=FALSE\n)\nrender_gif(p_split_check[,1:4],\n           guided_tour(lda_pp(p_split_check$species)),\n           display_xy( \n             col=p_split_check$species, \n             pch=p_split_check$type,\n             cex=1.5,\n             axes=\"bottomleft\"), \n           gif_file=\"gifs/p_split_guided.gif\",\n           frames=500,\n           loop=FALSE\n)\n```\n:::\n\n\n::: {.content-visible when-format=\"html\"}\n::: {#fig-p-split-html layout-ncol=2}\n\n![Grand tour](gifs/p_split.gif){#fig-split-grand fig-alt=\"FIX ME\" width=300}\n\n![Guided tour](gifs/p_split_guided.gif){#fig-split-guided fig-alt=\"FIX ME\" width=300}\n\nEvaluating the training/test split, where we expect that the two samples should roughly match. There are a few observations in the test set that are on the outer edges of the clusters, which will likely result in the model making an error in these regions. However, the two samples roughly match.\n:::\n:::\n\n::: {.content-visible when-format=\"pdf\"}\n::: {#fig-p-split-pdf layout-ncol=2}\n\n![Grand tour](images/p_split.png){#fig-split-grand fig-alt=\"FIX ME\" width=220}\n\n![Guided tour](images/p_split_guided.png){#fig-split-guided fig-alt=\"FIX ME\" width=220}\n\nEvaluating the training/test split, where we expect that the two samples should roughly match. There are a few observations in the test set that are on the outer edges of the clusters, which will likely result in the model making an error in these regions. However, the two samples roughly match.\n:::\n:::\n\n## Fit the model\n\\index{classification!Fitting a CNN}\n\nThe data needs to be specially formatted for the model fitted using `keras`. The explanatory variables need to be provided as a `matrix`, and the categorical response needs to be separate, and specified as a `numeric` variable, beginning with 0. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Data needs to be matrix, and response needs to be numeric\np_train_x <- p_train %>%\n  select(bl:bm) %>%\n  as.matrix()\np_train_y <- p_train %>% pull(species) %>% as.numeric() \np_train_y <- p_train_y-1 # Needs to be 0, 1, 2\np_test_x <- p_test %>%\n  select(bl:bm) %>%\n  as.matrix()\np_test_y <- p_test %>% pull(species) %>% as.numeric() \np_test_y <- p_test_y-1 # Needs to be 0, 1, 2\n```\n:::\n\n\nThe specified model is reasonably simple, four input variables, two nodes in the hidden layer and a three column binary matrix for output. This corresponds to 5+5+3+3+3=19 parameters. \n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nModel: \"sequential\"\n________________________________________________________________________________\n Layer (type)                       Output Shape                    Param #     \n================================================================================\n dense_1 (Dense)                    (None, 2)                       10          \n dense (Dense)                      (None, 3)                       9           \n================================================================================\nTotal params: 19 (76.00 Byte)\nTrainable params: 19 (76.00 Byte)\nNon-trainable params: 0 (0.00 Byte)\n________________________________________________________________________________\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Fit model\np_nn_fit <- p_nn_model %>% keras::fit(\n  x = p_train_x, \n  y = p_train_y,\n  epochs = 200,\n  verbose = 0\n)\n\n# Save model: does not work!\nsave_model_tf(p_nn_model, \"data/penguins_cnn\")\n```\n:::\n\n::: {.cell}\n\n:::\n\n\nBecause we set the random number seed we will get the same fit each time the code provided here is run. However, if the model is re-fit without setting the seed, you will see that there is a surprising amount of variability in the fits. Setting `epochs = 200` helps to usually get a good fit. One expects that `keras` is reasonably stable so one would not expect the huge array of fits as observed in @wickham2015 using `nnet`. That this can happen with the simple model used here reinforces the notion that fitting of neural network models is fiddly, and great care needs to be taken to validate and diagnose the fit. \n\n::: {.content-visible when-format=\"html\"}\n::: info\nFitting neural network models is fiddly, and very different fitted models can result from restarts, parameter choices, and architecture. \n:::\n:::\n\n::: {.content-visible when-format=\"pdf\"}\n\\infobox{Fitting neural network models is fiddly, and very different fitted models can result from restarts, parameter choices, and architecture.  \n}\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nlibrary(keras)\nlibrary(ggplot2)\nlibrary(colorspace)\n\n# load fitted model\np_nn_model <- load_model_tf(\"data/penguins_cnn\")\n```\n:::\n\n\nThe fitted model that we have chosen as the final one has reasonably small loss and high accuracy. Plots of loss and accuracy across epochs showing the change during  fitting can be plotted, but we don't show them here, because they are generally not very interesting.\n\n\n::: {.cell}\n\n```{.r .cell-code}\np_nn_model %>% evaluate(p_test_x, p_test_y, verbose = 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     loss  accuracy \n0.2563850 0.9553571 \n```\n:::\n:::\n\n\nThe model object can be saved for later use with:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Save model: does not work!\nsave_model_tf(p_nn_model, \"data/penguins_cnn\")\n```\n:::\n\n\n## Extracting model components\n\\index{classification!hidden layers}\n\n::: {.content-visible when-format=\"html\"}\n::: info\nView the individual node models to understand how they combine to produce the overall model.\n:::\n:::\n\n::: {.content-visible when-format=\"pdf\"}\n\\infobox{View the individual node models to understand how they combine to produce the overall model.\n}\n:::\n\nBecause nodes in the hidden layers of neural networks are themselves (relatively simple regression) models, it can be interesting to examine these to understand how the model is making it's predictions. Although it's rarely easy, most software will allow the coefficients for the models at these nodes to be extracted. With the penguins CNN model there are two nodes, so we can extract the coefficients and plot the resulting two linear combinations to examine the separation between classes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extract hidden layer model weights\np_nn_wgts <- keras::get_weights(p_nn_model, trainable=TRUE)\np_nn_wgts \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n           [,1]        [,2]\n[1,]  0.6216676  1.33304155\n[2,]  0.1851478 -0.01596385\n[3,] -0.1680396 -0.30432791\n[4,] -0.8867414 -0.36627045\n\n[[2]]\n[1]  0.12708087 -0.09466381\n\n[[3]]\n           [,1]     [,2]       [,3]\n[1,] -0.1646167 1.527644 -1.9215064\n[2,] -0.7547278 1.555889  0.3210194\n\n[[4]]\n[1]  0.4554813 -0.9371488  0.3577386\n```\n:::\n:::\n\n\nThe linear coefficients for the first node in the model are 0.62, 0.19, -0.17, -0.89, and the second node in the model are 1.33, -0.02, -0.3, -0.37. We can use these like we used the linear discriminants in LDA to make a 2D view of the data, where the model is separating the three species. The constants 0.13, -0.09 are not important for this. They are only useful for drawing the location of the boundaries between classes produced by the model.\n\nThese two sets of model coefficients provide linear combinations of the original variables. Together, they define a plane on which the data is projected to view the classification produced by the model. Ideally, though this plane should be defined using an orthonormal basis otherwise the shape of the data distribution might be warped. So we orthonormalise this matrix before computing the data projection.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Orthonormalise the weights to make 2D projection\np_nn_wgts_on <- tourr::orthonormalise(p_nn_wgts[[1]])\np_nn_wgts_on\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           [,1]       [,2]\n[1,]  0.5593355  0.7969849\n[2,]  0.1665838 -0.2145664\n[3,] -0.1511909 -0.1541475\n[4,] -0.7978314  0.5431528\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Hidden layer\np_train_m <- p_train %>%\n  mutate(nn1 = as.matrix(p_train[,1:4]) %*%\n           as.matrix(p_nn_wgts_on[,1], ncol=1),\n         nn2 = as.matrix(p_train[,1:4]) %*%\n           matrix(p_nn_wgts_on[,2], ncol=1))\n\n# Now add the test points on.\np_test_m <- p_test %>%\n  mutate(nn1 = as.matrix(p_test[,1:4]) %*%\n           as.matrix(p_nn_wgts_on[,1], ncol=1),\n         nn2 = as.matrix(p_test[,1:4]) %*%\n           matrix(p_nn_wgts_on[,2], ncol=1))\np_train_m <- p_train_m %>%\n  mutate(set = \"train\")\np_test_m <- p_test_m %>%\n  mutate(set = \"test\")\np_all_m <- bind_rows(p_train_m, p_test_m)\nggplot(p_all_m, aes(x=nn1, y=nn2, \n                     colour=species, shape=set)) + \n  geom_point() +\n  scale_colour_discrete_divergingx(palette=\"Zissou 1\") +\n  scale_shape_manual(values=c(16, 1)) +\n  theme_minimal() +\n  theme(aspect.ratio=1)\n```\n\n::: {.cell-output-display}\n![Plot of the data in the linear combinations from the two nodes in the hidden layer. The three species are clearly different, although with some overlap between all three. A main issue to notice is that there isn't a big gap between Gentoo and the other species, which we know is there based on our data exploration done in other chapters. This suggests this fitted model is sub-optimal.](17-nn_files/figure-html/fig-hidden-layer-1.png){#fig-hidden-layer fig-alt='FIXME' width=80%}\n:::\n:::\n\n\n@fig-hidden-layer shows the data projected into the plane determined by the two linear combinations of the two nodes in the hidden layer. Training and test sets are indicated by empty and solid circles. The three species are clearly different but there is some overlap or confusion for a few penguins. The most interesting aspect to learn is that there is no big gap between the Gentoo and other species, which we know exists in the data. The model has not found this gap, and thus is likely to unfortunately and erroneously confuse some Gentoo penguins, particularly with Adelie.\n\nWhat we have shown here is a process to use the models at the nodes of the hidden layer to produce a reduced dimensional space where the classes are best separated, at least as determined by the model. The process will work in higher dimensions also. \n\nWhen there are more nodes in the hidden layer than the number of original variables it means that the space is extended to achieve useful classifications that need more complicated non-linear boundaries. The extra nodes describe the non-linearity. @wickham2015 provides a good illustration of this in 2D. The process of examining each of the node models can be useful for understanding this non-linear separation, also in high dimensions.\n\n## Examining predictive probabilities\n\\index{classification!predictive probabilities}\n\nWhen the predictive probabilities are returned by a model, as is done by this CNN, we can use a ternary diagram for three class problems, or high-dimensional simplex when there are more classes to examine the strength of the classification. This done in the same way that was used for the votes matrix from a random forest in @sec-votes. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Predict training and test set\np_train_pred <- p_nn_model %>% \n  predict(p_train_x, verbose = 0)\np_train_pred_cat <- levels(p_train$species)[\n  apply(p_train_pred, 1,\n        which.max)]\np_train_pred_cat <- factor(\n  p_train_pred_cat,\n  levels=levels(p_train$species))\ntable(p_train$species, p_train_pred_cat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           p_train_pred_cat\n            Adelie Chinstrap Gentoo\n  Adelie        92         4      1\n  Chinstrap      0        45      0\n  Gentoo         1         0     78\n```\n:::\n\n```{.r .cell-code}\np_test_pred <- p_nn_model %>% \n  predict(p_test_x, verbose = 0)\np_test_pred_cat <- levels(p_test$species)[\n  apply(p_test_pred, 1, \n        which.max)]\np_test_pred_cat <- factor(\n  p_test_pred_cat,\n  levels=levels(p_test$species))\ntable(p_test$species, p_test_pred_cat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           p_test_pred_cat\n            Adelie Chinstrap Gentoo\n  Adelie        45         3      1\n  Chinstrap      0        23      0\n  Gentoo         1         0     39\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# Set up the data to make the ternary diagram\n# Join data sets\ncolnames(p_train_pred) <- c(\"Adelie\", \"Chinstrap\", \"Gentoo\")\ncolnames(p_test_pred) <- c(\"Adelie\", \"Chinstrap\", \"Gentoo\")\np_train_pred <- as_tibble(p_train_pred)\np_train_m <- p_train_m %>%\n  mutate(pspecies = p_train_pred_cat) %>%\n  bind_cols(p_train_pred) %>%\n  mutate(set = \"train\")\np_test_pred <- as_tibble(p_test_pred)\np_test_m <- p_test_m %>%\n  mutate(pspecies = p_test_pred_cat) %>%\n  bind_cols(p_test_pred) %>%\n  mutate(set = \"test\")\np_all_m <- bind_rows(p_train_m, p_test_m)\n\n# Add simplex to make ternary\nlibrary(geozoo)\nproj <- t(geozoo::f_helmert(3)[-1,])\np_nn_v_p <- as.matrix(p_all_m[,c(\"Adelie\", \"Chinstrap\", \"Gentoo\")]) %*% proj\ncolnames(p_nn_v_p) <- c(\"x1\", \"x2\")\np_nn_v_p <- p_nn_v_p %>%\n  as.data.frame() %>%\n  mutate(species = p_all_m$species,\n         set = p_all_m$set)\n\nsimp <- geozoo::simplex(p=2)\nsp <- data.frame(cbind(simp$points), simp$points[c(2,3,1),])\ncolnames(sp) <- c(\"x1\", \"x2\", \"x3\", \"x4\")\nsp$species = sort(unique(penguins_sub$species))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# Plot it\nggplot() +\n  geom_segment(data=sp, aes(x=x1, y=x2, xend=x3, yend=x4)) +\n  geom_text(data=sp, aes(x=x1, y=x2, label=species),\n            nudge_x=c(-0.1, 0.15, 0),\n            nudge_y=c(0.05, 0.05, -0.05)) +\n  geom_point(data=p_nn_v_p, aes(x=x1, y=x2, \n                                colour=species,\n                                shape=set), \n             size=2, alpha=0.5) +\n  scale_color_discrete_divergingx(palette=\"Zissou 1\") +\n  scale_shape_manual(values=c(19, 1)) +\n  theme_map() +\n  theme(aspect.ratio=1, legend.position = \"right\")\n```\n\n::: {.cell-output-display}\n![Ternary diagram for the three groups of the predictive probabilities of both training ans test sets. From what we already know about the penguins data this fit is not good. Both Chinstrap and Gentoo penguins are confused with Adelie, or at risk of it. Gentoo is very well-separated from the other two species when several variables are used, and this fitted model is blind to it. One useful finding is that there is little difference between training and test sets, so the model has not been over-fitted.](17-nn_files/figure-html/unnamed-chunk-17-1.png){width=70%}\n:::\n:::\n\n\n\n::: {.content-visible when-format=\"html\"}\n::: info\nIf the training and test sets look similar when plotted in the model space then the model is not suffering from over-fitting.\n:::\n:::\n\n::: {.content-visible when-format=\"pdf\"}\n\\infobox{If the training and test sets look similar when plotted in the model space then the model is not suffering from over-fitting. \n}\n:::\n\n## Local explanations\n\\index{classification!local explanations}\n\\index{classification!XAI}\n\nIt especially important to be able to interpret or explain a model, even more so when the model is complex or black-box'y. A good resource for learning about the range of methods is @iml. Local explanations provide some information about variables that are important for making the prediction for a particular observation. The method that we use here is Shapley value, as computed using the `kernelshap` package [@kernelshap]. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Explanations\n# https://www.r-bloggers.com/2022/08/kernel-shap/\nlibrary(kernelshap)\nlibrary(shapviz)\np_explain <- kernelshap(\n    p_nn_model,\n    p_train_x, \n    bg_X = p_train_x,\n    verbose = FALSE\n  )\np_exp_sv <- shapviz(p_explain)\nsave(p_exp_sv, file=\"data/p_exp_sv.rda\")\n```\n:::\n\n\nA Shapley value for an observation indicates how the variable contributes to the model prediction for that observation, relative to other variables. It is an average, computed from the change in prediction when all combinations of presence or absence of other variables. In the computation, for each combination, the prediction is computed by substituting absent variables with their average value, like one might do when imputing missing values. \n\n@fig-shapley-pcp shows the Shapley values for Gentoo observations (both training and test sets) in the penguins data, as a parallel coordinate plot. The values for the single misclassified Gentoo penguin (in the training set) is coloured orange. Overall, the Shapley values don't vary much on `bl`, `bd` and `fl` but they do on `bm`. The effect of other variables is seems to be only important for `bm`. \n\nFor the misclassified penguin, the effect of `bm` for all combinations of other variables leads to a decline in predicted value, thus less confidence in it being a Gentoo. In contrast, for this same penguin when considering the effect of `bl` the predicted value increases on average. \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nload(\"data/p_exp_sv.rda\")\np_exp_gentoo <- p_exp_sv$Class_3$S\np_exp_gentoo <- p_exp_gentoo %>%\n  as_tibble() %>%\n  mutate(species = p_train$species,\n         pspecies = p_train_pred_cat,\n  ) %>%\n  mutate(error = ifelse(species == pspecies, 0, 1))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\np_exp_gentoo %>%\n  filter(species == \"Gentoo\") %>%\n  pivot_longer(bl:bm, names_to=\"var\", values_to=\"shap\") %>%\n  mutate(var = factor(var, levels=c(\"bl\", \"bd\", \"fl\", \"bm\"))) %>%\n  ggplot(aes(x=var, y=shap, colour=factor(error))) +\n  geom_quasirandom(alpha=0.8) +\n  scale_colour_discrete_divergingx(palette=\"Geyser\") +\n  #facet_wrap(~var) +\n  xlab(\"\") + ylab(\"SHAP\") +\n  theme_minimal() + \n  theme(legend.position = \"none\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nlibrary(ggpcp)\np_exp_gentoo %>%\n  filter(species == \"Gentoo\") %>%\n  pcp_select(1:4) %>%\n  ggplot(aes_pcp()) +\n    geom_pcp_axes() + \n    geom_pcp_boxes(fill=\"grey80\") + \n    geom_pcp(aes(colour = factor(error)), \n             linewidth = 2, alpha=0.3) +\n  scale_colour_discrete_divergingx(palette=\"Geyser\") +\n  xlab(\"\") + ylab(\"SHAP\") +\n  theme_minimal() + \n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![SHAP values focused on Gentoo class, for each variable. The one misclassified penguin (orange) has a much lower value for body mass, suggesting that this variable is used differently for the prediction than for other penguins.](17-nn_files/figure-html/fig-shapley-pcp-1.png){#fig-shapley-pcp fig-alt='FIXME' width=80%}\n:::\n:::\n\n\nIf we examine the data [@fig-penguins-bl-bm-bd] the explanation makes some sense. The misclassified penguin has an unusually small value on `bm`. That the SHAP value for `bm` was quite different pointed to this being a potential issue with the model, particularly for this penguin. This penguin's prediction is negatively impacted by `bm` being in the model.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nlibrary(patchwork)\n# Check position on bm\nshap_proj <- p_exp_gentoo %>%\n  filter(species == \"Gentoo\", error == 1) %>%\n  select(bl:bm)\nshap_proj <- as.matrix(shap_proj/sqrt(sum(shap_proj^2)))\np_exp_gentoo_proj <- p_exp_gentoo %>%\n  rename(shap_bl = bl, \n         shap_bd = bd,\n         shap_fl = fl, \n         shap_bm = bm) %>%\n  bind_cols(as_tibble(p_train_x)) %>%\n  mutate(shap1 = shap_proj[1]*bl+\n           shap_proj[2]*bd+\n           shap_proj[3]*fl+\n           shap_proj[4]*bm)\nsp1 <- ggplot(p_exp_gentoo_proj, aes(x=bm, y=bl, \n             colour=species, \n             shape=factor(1-error))) +\n    geom_point(alpha=0.8) +\n  scale_colour_discrete_divergingx(palette=\"Zissou 1\") +\n  scale_shape_manual(\"error\", values=c(19, 1)) +\n  theme_minimal() + \n  theme(aspect.ratio=1, legend.position=\"bottom\")\nsp2 <- ggplot(p_exp_gentoo_proj, aes(x=bm, y=shap1, \n             colour=species, \n             shape=factor(1-error))) +\n    geom_point(alpha=0.8) +\n  scale_colour_discrete_divergingx(palette=\"Zissou 1\") +\n  scale_shape_manual(\"error\", values=c(19, 1)) +\n  ylab(\"SHAP\") +\n  theme_minimal() + \n  theme(aspect.ratio=1, legend.position=\"bottom\")\nsp2 <- ggplot(p_exp_gentoo_proj, aes(x=shap1, \n             fill=species, colour=species)) +\n  geom_density(alpha=0.5) +\n  geom_vline(xintercept = p_exp_gentoo_proj$shap1[\n    p_exp_gentoo_proj$species==\"Gentoo\" &\n    p_exp_gentoo_proj$error==1], colour=\"black\") +\n  scale_fill_discrete_divergingx(palette=\"Zissou 1\") +\n  scale_colour_discrete_divergingx(palette=\"Zissou 1\") +\n  theme_minimal() + \n  theme(aspect.ratio=1, legend.position=\"bottom\")\nsp2 <- ggplot(p_exp_gentoo_proj, aes(x=bm, y=bd, \n             colour=species, \n             shape=factor(1-error))) +\n    geom_point(alpha=0.8) +\n  scale_colour_discrete_divergingx(palette=\"Zissou 1\") +\n  scale_shape_manual(\"error\", values=c(19, 1)) +\n  theme_minimal() + \n  theme(aspect.ratio=1, legend.position=\"bottom\")\nsp1 + sp2 + plot_layout(ncol=2, guides = \"collect\") &\n  theme(legend.position=\"bottom\",\n        legend.direction=\"vertical\")\n```\n\n::: {.cell-output-display}\n![Plots of the data to help understand what the SHAP values indicate. The misclassified Gentoo penguin has an unusually low body mass value which makes it appear to be more like an Adelie penguin, particularly when considered in relation to it's bill length.](17-nn_files/figure-html/fig-penguins-bl-bm-bd-1.png){#fig-penguins-bl-bm-bd fig-alt='FIXME' width=100%}\n:::\n:::\n\n\n## Examining boundaries\n\nCheck against LDA, suspect that `bm` is used too much in CNN model.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# Generate grid over explanatory variables\np_grid <- tibble(\n  bl = runif(10000, min(penguins_sub$bl), max(penguins_sub$bl)),\n  bd = runif(10000, min(penguins_sub$bd), max(penguins_sub$bd)),\n  fl = runif(10000, min(penguins_sub$fl), max(penguins_sub$fl)),\n  bm = runif(10000, min(penguins_sub$bm), max(penguins_sub$bm))\n)\n# Predict grid\np_grid_pred <- p_nn_model %>%\n  predict(as.matrix(p_grid), verbose=0)\np_grid_pred_cat <- levels(p_train$species)[apply(p_grid_pred, 1, which.max)]\np_grid_pred_cat <- factor(p_grid_pred_cat,\n                          levels=levels(p_train$species))\n\n# Project into weights from the two nodes\np_grid_proj <- as.matrix(p_grid) %*% p_nn_wgts_on\ncolnames(p_grid_proj) <- c(\"nn1\", \"nn2\")\np_grid_proj <- p_grid_proj %>% \n  as_tibble() %>%\n  mutate(species = p_grid_pred_cat)\n\n# Plot\nggplot(p_grid_proj, aes(x=nn1, y=nn2, \n                     colour=species)) + \n  geom_point(alpha=0.5) +\n  geom_point(data=p_all_m, aes(x=nn1, \n                               y=nn2, \n                               shape=species),\n             inherit.aes = FALSE) +\n  scale_colour_discrete_divergingx(palette=\"Zissou 1\") +\n  scale_shape_manual(values=c(1, 2, 3)) +\n  theme_minimal() +\n  theme(aspect.ratio=1, \n        legend.position = \"bottom\",\n        legend.title = element_blank())\n```\n\n::: {.cell-output-display}\n![](17-nn_files/figure-html/fig-penguins-nn-boundaries-1.png){#fig-penguins-nn-boundaries width=672}\n:::\n:::\n\n\n\n::: {.content-visible when-format=\"html\"}\n\n::: {#fig-penguins-lda-nn-html layout-ncol=2}\n\n![LDA model](gifs/penguins_lda_boundaries.gif){#fig-lda-boundary fig-alt=\"FIX ME\" width=300}\n\n![NN model](gifs/penguins_nn_boundaries.gif){#fig-tree-boundary fig-alt=\"FIX ME\" width=300}\n\nComparison of the boundaries produced by the LDA (a) and the CNN (b) model, using a slice tour. \n:::\n:::\n\n::: {.content-visible when-format=\"pdf\"}\n\n::: {#fig-penguins-lda-nn-pdf layout-ncol=2}\n\n![LDA model](images/fig-lda-2D-boundaries-1.png){#fig-lda-boundary fig-alt=\"FIX ME\" width=200}\n\n![NN model](images/penguins_nn_boundaries-1.png){#fig-nn-boundary fig-alt=\"FIX ME\" width=250}\n\nComparison of the boundaries produced by the LDA (a) and the CNN (b) model, using a slice tour. \n:::\n:::\n\n\\index{tour!slice} \n\n\n<!--\nThis chapter will likely include:\n\n- Models at nodes or epochs \n- Predictions (like vote matrix) for training and test. It provides a visual guide to overfitting.\n- Classification boundaries comparison with other methods\n- Explainability and interpretability\n\n(This paper https://distill.pub/2020/grand-tour/ has good examples)\n\nNOTE: Results might vary with different knits \n\nReferences keras/tensorflow book, tidymodels, interpretable machine learning, and removing the blindfold\n\n\nOutline for chapter:\n\n- Penguins data\n    - Setting up with the CNN with keras\n    - Splitting training and test, checking\n    - Specifying model, choices of layers\n    - Making predictions\n    - Extracting weights\n    - Building your diagnostic data set\n    - Examine predictive probabilities with simplex\n    - Examining the nodes - like the discriminant space when its 2\n    - Misclassifications\n    - \n\nBushfires\n    - Model fitting when regularisation needed\n    - Overfitting\n    \nSketches as an example  \n-->\n\n## Exercises {-}\n\n1. The problem with the CNN model fitted to the penguins is that the Gentoo are poorly classified, when they should be perfectly predictable due to the big gap between class clusters. Re-fit the CNN to the penguins data, to find a better model that appropriately perfectly predicts Gentoo penguins. Support this by plotting the model (using the hiddne layer), and the predictive probabilities as a ternary plot. Do the SHAP values also support that `bd` plays a stronger role in your best model? (`bd` is the main variable for distinguishing Gentoo's from the other species, particularly when used with `fl` or `bl`.)\n",
    "supporting": [
      "17-nn_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}