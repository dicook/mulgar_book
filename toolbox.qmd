# Toolbox {#toolbox}


## Using tours in the `tourr` package

### Installation

You can install the released version of `tourr` from [CRAN](https://CRAN.R-project.org) with:

``` r
install.packages("tourr")
```

and the development version from the [GitHub repo](https://github.com/ggobi/tourr) with:

``` r
# install.packages("remotes")
remotes::install_github("ggobi/tourr")
```

### Getting started

To run a tour in R, use one of the animate functions. The following code will show a 2D tour displayed as a scatterplot on a 6D data set with three labelled classes. 

``` r
animate_xy(flea[,-7], col=flea$species)
```

@tourr remains a good reference for learning more about this package. The package [website](http://ggobi.github.io/tourr/) has a list of current functionality. 

### Different tours

The two main components of the tour algorithm are the projection dimension which affects the choice of display to use, and the algorithm that delivers the projection sequence. The primary functions for these two parts are 

1. For display of different projection dimensions:

- `display_dist()`: choice of density, histogram or average shifted histogram (ash) display of the 1D projections.
- `display_xy()`, `display_density2d()`, `display_groupxy()`, `display_pca()`, `display_sage()`, `display_slice()`, `display_trails()`: choices in display of 2D projections.
- `display_depth()`, `display_stereo()`: choices to display 3D projections. 
- `display_pcp()`, `display_scatmat()`, `display_stars()`, `display_faces()`: choices for displaying three or more variables.
- `display_image()`: to use with multispectral images, where different combinations of spectral bands are displayed. See @WPS98 and @Symanzik2002NewAO for applications.
- `dependence_tour()`: displaying two groups of variables as in multiple regression, or multivariate regression or canonical correlation analysis, as two independent 1D projections.
- `display_andrews()`: 1D projections as Andrews curves.

2. To change the way projections are delivered:

- `grand_tour()`: Smooth sequence of random projections to view all possible projections as quickly as possible. Good for getting an overview of the high-dimensional data, especially when you don't know what you are looking for. 
- `guided_tour()`: Follow a projection pursuit optimisation to find projections that have particular patterns. This is used when you want to learn if the data has particular patterns, such as clustering or outliers. Use the `holes()` index to find projections with gaps that allow one to see clusters, or `lda_pp()` or `pda_pp()` when class labels are known and you want to find the projections where the clusters are separated. 
- `little_tour()`: Smoothly interpolate between pairs of variables, to show all the marginal views of the data.
- `local_tour()`: Makes small movements around a chosen projections to explore a small neighbourhood. Very useful to learn if small distances away from a projection change the pattern substantially or not.
- `radial_tour()`: Interpolates a chosen variable out of the projection, and then back into the projection. This is useful for assessing importance of variables to pattern in a projection. If the pattern changes a lot when the variable is rotated out, then the variable is important for producing it.
- `dependendence_tour()`: Delivers two sequences of 1D grand tours, to examine associations between two sets of variables.
- `frozen_tour()`: This is an interesting one! it allows the coefficient for some variables to be fixed, and others to vary.

### The importance of scale

Scaling of multivariate data is really important in many ways. It affects most model fitting, and can affect the perception of patterns when data is visualised. Here we describe a few scaling issues to take control of when using tours.


**Pre-processing data**

It is generally useful to standardise your data to have mean 0 and variance-covariance equal to the identity matrix before using the tour. We use the tour to discover associations between variables. Characteristics of single variables should be examined and understood before embarking on looking for high-dimensional structure. 

The `rescale` parameter in the `animate()` function will scale all variables to range between 0 and 1, prior to starting the tour. This will force all to have the same range. It is the default, and without this data with different ranges across variable may have some strange patterns. If you have already scaled the data yourself, even if using a different scaling such as using standardised variables you should set `rescale=FALSE`.

A more severe transformation that can be useful prior to starting a tour is to **sphere** the data. This is also an option in the `animate()` function, but is `FALSE` by default. Sphering is the same as conducting a principal component analysis, and using the principal components as the variables. It removes all linear association between variables! This can be especially useful if you want to focus on finding non-linear associations, including clusters, and outliers. 

**Scaling to fit into plot region**

The `half_range` parameter in most of the display types sets the range used to scale the data into the plot. It is estimated when a tour is started, but you may need to change it if you find that the data keeps escaping the plot window or is not fully using the space. Space expands exponentially as dimension increases, and the estimation takes this into account. However, different distributions of data points lead to different variance of observations in high-dimensional space. A skewed distribution will be more varied than a normal distribution. It is hard to estimate precisely how the data should be scaled so that it fits nicely into the plot space for all projections viewed. 

The `center` parameter is used to centre each projection by setting the mean to be at the middle of the plot space. With different distributions the mean of the data can vary around the plot region, and this can be distracting. Fixing the mean of each projection to always be at the center of the plot space makes it easier to focus on other patterns.

### Saving your tour

The functions `save_history()` and `planned_tour()` allow the tour path to be pre-computed, and re-played in your chosen way. The tour path is saved as a list of projection vectors, which can also be passed to external software for displaying tours easily. Only a minimal set of projections is saved, by default, and a full interpolation path of projections can always be generated from it using the `interpolate()` function.

Versions and elements of tours can be saved for publication using a variety of functions:

- `render_gif()`: Save a tour as an animated gif, using the `gifski` package.
- `render_proj()`: Save an object that can be used to produce a polished rendering of a single projection, possibly with `ggplot`.
- `render_anim()`: Creates an object containing a sequence of projections that can be used with `plotly()` to produce an HTML animation, with interactive control.

### Understanding your tour path

Grand tour, and show paths on the space, starting with 1D. How more time gives more coverage of the sphere. Then the torus and paths on torus.

```{r}
#| echo: false
#| eval: false
library(ferrn)
library(tourr)
library(geozoo)
library(dplyr)
library(purrr)
flea_std <- apply(flea[,1:6], 2, function(x) (x-mean(x))/sd(x))

# 1D paths
set.seed(1101)
gt1 <- save_history(flea_std[,c(1,4,5)], 
                    tour_path = grand_tour(1), 
                    max_bases=30)
pp1 <- save_history(flea_std[,c(1,4,5)], 
  tour_path = guided_tour(holes(), d=1))
gt1i <- interpolate(gt1)
pp1i <- interpolate(pp1)

#s1 <- sphere.hollow(3, 5000)$points
s1 <- map(1:5000, ~basis_random(n = 3,  d=1)) %>%
  purrr::flatten_dbl() %>% matrix(ncol = 3, byrow = TRUE) 
gt1_m <- apply(gt1i, 1, c)
pp1_m <- apply(pp1i, 1, c)
s1 <- bind_cols(s1, rep("sphere", 5000))
gt1_m <- bind_cols(gt1_m, rep("grand", nrow(gt1_m)))
pp1_m <- bind_cols(pp1_m, rep("guided", nrow(pp1_m)))
p1 <- rbind(s1, gt1_m, pp1_m)
colnames(p1) <- c(paste0("V", 1:3), "type")
p1$type <- factor(p1$type, levels=c("grand", "sphere", "guided"))
animate_xy(p1[,1:3], col=p1$type, palette="Teal-Rose", 
           cex=c(rep(0.5, 5000), rep(1, nrow(p1)-5000)),
                 axes="off")
render_gif(p1[,1:3],           
           grand_tour(),
           display_xy(col=p1$type, palette="Teal-Rose", 
           cex=c(rep(0.5, 5000), rep(1, nrow(p1)-5000)),
                 axes="off"),
           gif_file = "gifs/tour_paths1d.gif",
           frames = 500,
           width = 300, 
           height = 300)

# 2D paths
set.seed(1209)
gt2 <- save_history(flea_std[,c(1, 4, 5)], 
                    tour_path = grand_tour(), 
                    max_bases=30)
pp2 <- save_history(flea_std[,c(1, 4, 5)], 
  tour_path = guided_tour(holes()))
gt2i <- interpolate(gt2)
pp2i <- interpolate(pp2)

s2 <- map(1:5000, ~basis_random(n=3,  d=2)) %>%
  purrr::flatten_dbl() %>% matrix(ncol = 6, byrow = TRUE) 
gt2_m1 <- apply(gt2i[,1,], 1, c)
gt2_m2 <- apply(gt2i[,2,], 1, c)
gt2_m <- bind_cols(gt2_m1, gt2_m2)
pp2_m1 <- apply(pp2i[,1,], 1, c)
pp2_m2 <- apply(pp2i[,2,], 1, c)
pp2_m <- bind_cols(pp2_m1, pp2_m2)
s2 <- bind_cols(s2, rep("sphere", 5000))
gt2_m <- bind_cols(gt2_m, rep("grand", nrow(gt2_m)))
pp2_m <- bind_cols(pp2_m, rep("guided", nrow(pp2_m)))
p2 <- rbind(s2, gt2_m, pp2_m)
colnames(p2) <- c(paste0("V", 1:6), "type")
p2$type <- factor(p2$type, levels=c("grand", "sphere", "guided"))
animate_xy(p2[,1:6], col=p2$type, palette="Teal-Rose", 
           cex=c(rep(0.5, 5000), rep(1, nrow(p2)-5000)),
                 axes="off")
render_gif(p2[,1:6],           
           grand_tour(),
           display_xy(col=p2$type, palette="Teal-Rose", 
           cex=c(rep(0.5, 5000), rep(1, nrow(p2)-5000)),
                 axes="off"),
           gif_file = "gifs/tour_paths2d.gif",
           frames = 500,
           width = 300, 
           height = 300)
```
::: {.content-hidden when-format="pdf"}
![1D tour paths](gifs/tour_paths1d.gif){#fig-tourpaths1d}
![2D tour paths](gifs/tour_paths2d.gif){#fig-tourpaths2d}

Grand and guided tour paths of 1D and 2D projections of 3D data. The light points represent the space of all 1D and 2D projections respectively. You can see the grand tour is more comprehensively covering the space, as expected, whereas the guided tour is more focused, and quickly moves to the best projection. 
:::

## What not to do

- Categorical data, or discrete data
- When time or space is a variable

## Tours in other software

Also include other software now available

- detourr
- langevitour
- woylier
- spinifex
- ferrn

