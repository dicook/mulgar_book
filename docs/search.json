[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Interactive and dynamic graphics for high-dimensional data using R",
    "section": "",
    "text": "Although there are many resources available for data visualization, there are few comprehensive resources on high-dimensional data visualisation. This book fills this gap by providing a comprehensive and up-to-date guide to visualising high-dimensional data and models, with R.\nHigh-dimensional data spaces are fascinating places. You may think that there’s a lot of ways to plot one or two variables, and a lot of types of patterns that can be found. You might use a density plot and see skewness or a dot plot to find outliers. A scatterplot of two variables might reveal a non-linear relationship or a barrier beyond which no observations exist. We don’t as yet have so many different choices of plot types for high-dimensions, but these types of patterns are also what we seek in scatterplots of high-dimensional data. The additional dimensions can clarify these patterns, that clusters are likely to be more distinct. Observations that did not appear to be very different can be seen to be lonely anomalies in high-dimensions, that no other observations have quite the same combination of values.\nIf you encounter an error, you can report it as an issue at the Github repo for this book.\nPlease make a small reproducible example and report the error encountered. Reproducible examples have these components:"
  },
  {
    "objectID": "index.html#audience",
    "href": "index.html#audience",
    "title": "Interactive and dynamic graphics for high-dimensional data using R",
    "section": "Audience",
    "text": "Audience\nHigh-dimensional data arises in many fields such as biology, social sciences, finance, and more. Anyone who is doing exploratory data analysis and model fitting for more than two variables will benefit from learning how to effectively visualise high-dimensions. This book will be useful for students and teachers of mulitvariate data analysis and machine learning, and researchers, data analysts, and industry professionals who work in these areas."
  },
  {
    "objectID": "index.html#how-to-use-the-book",
    "href": "index.html#how-to-use-the-book",
    "title": "Interactive and dynamic graphics for high-dimensional data using R",
    "section": "How to use the book?",
    "text": "How to use the book?\nThe book is written with explanations followed by examples with R code. The toolbox chapter provides an overview of the primary high-dimensional visualisation methods. The remaining chapters focus on different application areas and how to use the high-dimensional visualisation to complement commonly used analytical methods.\n\nWhat should I know before reading this book?\nThe examples assume that you already use R, and have a working knowledge of base R and tidyverse way of thinking about data analysis. It also assumes that you have some knowledge of statistical methods, and some experience with machine learning methods.\nIf you feel like you need build up your skills in these areas in preparation for working through this book, these are our recommended resources:\n\nR for Data Science by Wickham and Grolemund for learning about tidyverse.\nIntroduction to Modern Statistics by Çetinkaya-Rundel and Hardin to learn about introductory statistics.\nHands-On Machine Learning with R by Boehmke and Greenwell to learn about machine learning."
  },
  {
    "objectID": "index.html#setting-up-your-workflow",
    "href": "index.html#setting-up-your-workflow",
    "title": "Interactive and dynamic graphics for high-dimensional data using R",
    "section": "Setting up your workflow",
    "text": "Setting up your workflow\nTo get started set up your computer with the current versions of R and Rstudio Desktop.\nIn addition, we have made an R package to share the data and functions used in this book, called mulgar.12\n\ninstall.packages(\"mulgar\")\n#| or the development version\ndevtools::install_github(\"dicook/mulgar\")"
  },
  {
    "objectID": "data.html#australian-football-league-women",
    "href": "data.html#australian-football-league-women",
    "title": "Appendix B — Data",
    "section": "B.1 Australian Football League Women",
    "text": "B.1 Australian Football League Women\n\nDescription\nThis is data from the 2021 Women’s Australian Football League. These are average player statistics across the season, with game statistics provided by the fitzRoy package. If you are new to the game of AFL, there is a nice explanation on Wikipedia.\n\n\nVariables\n\n\nRows: 381\nColumns: 35\n$ id              <chr> \"CD_I1001678\", \"CD_I1001679\", \"CD_I1001681\", \"CD_I1001…\n$ given_name      <chr> \"Jordan\", \"Brianna\", \"Jodie\", \"Ebony\", \"Emma\", \"Pepa\",…\n$ surname         <chr> \"Zanchetta\", \"Green\", \"Hicks\", \"Antonio\", \"King\", \"Ran…\n$ number          <int> 2, 3, 5, 12, 60, 21, 22, 23, 35, 14, 3, 8, 16, 12, 19,…\n$ team            <chr> \"Brisbane Lions\", \"West Coast Eagles\", \"GWS Giants\", \"…\n$ position        <chr> \"INT\", \"INT\", \"HFFR\", \"WL\", \"RK\", \"BPL\", \"INT\", \"INT\",…\n$ time_pct        <dbl> 63.00000, 61.25000, 76.50000, 74.90000, 85.10000, 77.4…\n$ goals           <dbl> 0.0000000, 0.0000000, 0.0000000, 0.1000000, 0.6000000,…\n$ behinds         <dbl> 0.0000000, 0.0000000, 0.5000000, 0.4000000, 0.4000000,…\n$ kicks           <dbl> 5.000000, 2.500000, 3.750000, 8.800000, 4.100000, 3.22…\n$ handballs       <dbl> 2.500000, 3.750000, 3.000000, 3.600000, 2.700000, 2.22…\n$ disposals       <dbl> 7.500000, 6.250000, 6.750000, 12.400000, 6.800000, 5.4…\n$ marks           <dbl> 1.5000000, 0.2500000, 1.0000000, 3.7000000, 2.2000000,…\n$ bounces         <dbl> 0.0000000, 0.0000000, 0.0000000, 0.6000000, 0.1000000,…\n$ tackles         <dbl> 3.000000, 2.250000, 2.250000, 3.900000, 2.000000, 1.77…\n$ contested       <dbl> 3.500000, 2.250000, 3.500000, 5.700000, 4.400000, 2.66…\n$ uncontested     <dbl> 3.500000, 4.500000, 3.000000, 7.000000, 2.800000, 1.77…\n$ possessions     <dbl> 7.000000, 6.750000, 6.500000, 12.700000, 7.200000, 4.4…\n$ marks_in50      <dbl> 1.0000000, 0.0000000, 0.2500000, 0.5000000, 0.9000000,…\n$ contested_marks <dbl> 1.0000000, 0.0000000, 0.0000000, 0.4000000, 1.2000000,…\n$ hitouts         <dbl> 0.0000000, 0.0000000, 0.0000000, 0.0000000, 19.4000000…\n$ one_pct         <dbl> 0.0000000, 1.5000000, 0.5000000, 1.2000000, 2.6000000,…\n$ disposal        <dbl> 60.25000, 67.15000, 37.20000, 65.96000, 61.72000, 66.8…\n$ clangers        <dbl> 2.000000, 0.500000, 2.500000, 3.100000, 2.400000, 1.33…\n$ frees_for       <dbl> 1.0000000, 0.5000000, 0.2500000, 2.5000000, 0.5000000,…\n$ frees_against   <dbl> 1.0000000, 0.5000000, 1.2500000, 1.3000000, 1.1000000,…\n$ rebounds_in50   <dbl> 0.0000000, 0.5000000, 0.2500000, 1.1000000, 0.0000000,…\n$ assists         <dbl> 0.00000000, 0.00000000, 0.00000000, 0.20000000, 0.2000…\n$ accuracy        <dbl> 0.00000, 0.00000, 0.00000, 5.00000, 30.00000, 0.00000,…\n$ turnovers       <dbl> 1.500000, 1.000000, 2.500000, 4.000000, 1.700000, 1.22…\n$ intercepts      <dbl> 2.0000000, 2.0000000, 0.5000000, 5.3000000, 1.3000000,…\n$ tackles_in50    <dbl> 0.5000000, 0.0000000, 0.7500000, 0.5000000, 0.5000000,…\n$ shots           <dbl> 0.5000000, 0.0000000, 0.7500000, 1.0000000, 1.2000000,…\n$ metres          <dbl> 72.50000, 58.50000, 76.00000, 225.90000, 89.80000, 76.…\n$ clearances      <dbl> 0.5000000, 0.2500000, 1.2500000, 0.4000000, 0.9000000,…\n\n\n\n\nPurpose\nThe primary analysis is to summarise the variation using principal component analysis, which gives information about relationships between the statistics or skills sets common in players. One also might be tempted to cluster the players, but there are no obvious clusters so it could be frustrating. At best one could partition the players into groups, while recognising there are no absolutely distinct and separated groups.\n\n\nSource\nSee the information provided with the fitzRoy package.\n\n\nPre-processing\nThe code for downloading and pre-processing the data is available at the mulgar website in the data-raw folder. The data provided by the fitzRoy package was pre-processed to reduce the variables to only those that relate to player skills and performance. It is possible that using some transformations on the variables would be useful to make them less skewed."
  },
  {
    "objectID": "data.html#notes-to-self",
    "href": "data.html#notes-to-self",
    "title": "Appendix B — Data",
    "section": "B.2 Notes to self",
    "text": "B.2 Notes to self\nThere were fifteen datasets listed in chapter 7 of the first edition. Several of these were related to networks which we are not including this time. I have tried to give a mix of things on a variety of topics. It would be nice to see if there’s updated versions of the “tips” (there seems to be a lot of noise in the literature here and no open datasets) and Di’s music data (perhaps we could scrape our own spotify accounts to get an equivalent), there are also a few audio challenge datasets like FSD50K . I think it would be useful to have more unstructured data sets like natural text that we have used for 1010.\n\nOther possible sources for data\nThere are now many search engines available for datasets that originate from research contexts that list licensing information and DOIs:\n\nhttps://zenodo.org (mostly ecology/biology)\nhttps://datadryad.org/stash (mostly biology)\nhttps://dataverse.harvard.edu/dataverse/harvard/ (mostly social sciences, but has a mixture of things)\nThere’s also a big list of datasets here: https://docs.google.com/spreadsheets/d/1ejOJTNTL5ApCuGTUciV0REEEAqvhI2Rd2FCoj7afops/edit#gid=0 (all psychology related)\nTidyTuesday\n\nhttps://github.com/rfordatascience/tidytuesday/blob/master/data/2022/2022-03-29/readme.md Would need to rearrange data to look at count, participation, revenue, expenditure\n\ngapminder\naccounting records\nLyn’s ecology data\nlearningtower, yowie"
  },
  {
    "objectID": "hierarchical-clustering.html",
    "href": "hierarchical-clustering.html",
    "title": "8  Hierarchical clustering",
    "section": "",
    "text": "Hierarchical cluster algorithms sequentially fuse neighboring points to form ever-larger clusters, starting from a full interpoint distance matrix. Figure 8.1 illustrates the hierarchical clustering approach for a simple simulated data set (a) with two well-separated clusters in 2D. The dendrogram (b) is a representation of the order that points are joined into clusters. The dendrogram strongly indicates two clusters because there are two branches branches representing the last join are much longer than all of the other branches. Although, the dendrogram is usually a good summary of the steps taken by the algorithm, it can be misleading. The dendrogram might strongly suggest a clustering but it might be a terrible solution. To check this we need to show the model with the data, as shown in plot (c). The segments show how the points and clusters are joined. Note that once points are joined into a cluster, the centroid of that cluster is used as the join location with other points or other clusters, and this is represented by a “+”. We can see that the longest edge is the one stretching across the gap between the two clusters, which is the location where the dendrogram would be cut to produce the two-cluster solution. This two-cluster solution is shown in plot (d).\n\n\nCode\nlibrary(ggplot2)\nlibrary(mulgar)\ndata(simple_clusters)\n# Data has two well-separated clusters\npd <- ggplot(simple_clusters, aes(x=x1, y=x2)) +\n  geom_point(colour=\"orange\", size=2, alpha=0.8) +\n  ggtitle(\"(a)\") +\n  theme(aspect.ratio=1) \n\n# Compute hierarchical clustering with Ward's linkage\ncl_hw <- hclust(dist(simple_clusters[,1:2]),\n                method=\"ward.D2\")\nlibrary(ggdendro)\ncl_ggd <- dendro_data(cl_hw, type = \"triangle\")\nph <- ggplot() +\n  geom_segment(data=cl_ggd$segments, \n               aes(x = x, y = y, \n                   xend = xend, yend = yend)) + \n  geom_point(data=cl_ggd$labels, aes(x=x, y=y),\n             colour=\"orange\", alpha=0.8) +\n  ggtitle(\"(b)\") +\n  theme_dendro()\n\n# Compute dendrogram in data\ncl_hfly <- hierfly(simple_clusters, cl_hw, scale=FALSE)\n\npdh <- ggplot() +\n  geom_segment(data=cl_hfly$segments, \n                aes(x=x, xend=xend,\n                    y=y, yend=yend)) +\n  geom_point(data=cl_hfly$data, \n             aes(x=x1, y=x2,\n                 shape=factor(node),\n                 colour=factor(node),\n                 size=1-node), alpha=0.8) +\n  scale_shape_manual(values = c(16, 3)) +\n  scale_colour_manual(values = c(\"orange\", \"black\")) +\n  scale_size(limits=c(0,17)) +\n  ggtitle(\"(c)\") +\n  theme(aspect.ratio=1, legend.position=\"none\")\n\n# Show result\nlibrary(dplyr)\nsimple_clusters <- simple_clusters %>%\n  mutate(clw = factor(cutree(cl_hw, 2)))\npc <- ggplot(simple_clusters) +\n  geom_point(aes(x=x1, y=x2, colour=clw), \n             size=2, alpha=0.8) +\n  scale_colour_brewer(palette=\"Set1\") +\n  ggtitle(\"(d)\") +\n  theme(aspect.ratio=1, legend.position=\"none\")\n\nlibrary(patchwork)\npd + ph + pdh + pc + plot_layout(ncol=2)\n\n\n\n\n\nFigure 8.1: Hierarchical clustering on simulated data: (a) data, (b) dendrogram, (c) dendrogram on the data, and (d) two cluster solution. Nodes of the dendrogram indicated by + when it is drawn on the data.\n\n\n\n\nDistance between clusters is described by a “linkage method”: For example, single linkage uses the smallest interpoint distance between the members of a pair of clusters, complete linkage uses the maximum interpoint distance, and average linkage uses the average of the interpoint distances. A good discussion on cluster analysis can be found in Boehmke and Greenwell (2019), on Wikipedia or any multivariate textbook.\n–THIS STUFF IS THE OLD MATERIAL–\n?fig-prim7-hier contains several plots that illustrate the results of the hierarchical clustering of the particle physics data; we used Euclidean interpoint distances and the average linkage method. This is computed by:\n> library(rggobi)\n> d.prim7 <- read.csv(\"prim7.csv\")\n> d.prim7.dist <- dist(d.prim7)\n> d.prim7.dend <- hclust(d.prim7.dist, method=\"average\")\n> plot(d.prim7.dend)\n\nThe dendrogram at the top shows the result of the clustering process. Several large clusters were fused late in the process, with heights (indicated by the height of the horizontal segment connecting two clusters) well above those of the first joins; we will want to look at these. Two points were fused with the rest at the very last stages, which indicates that they are outliers and have been assigned to singleton clusters.\n\n We cut the dendrogram to produce nine clusters because we would expect to see seven clusters and a few outliers based on our observations from the spin and brush approach, and our choice looks reasonable given the structure of the dendrogram. (In practice, we would usually explore the clusters corresponding to several different cuts of the dendrogram.) We assign each cluster an integer identifier, and in the following plots, you see the results of highlighting one cluster at a time and then running the grand tour to focus on the placement of that cluster within the data. This R code follows this sequence of actions:\n> gd <- ggobi(d.prim7)[1]\n> clust9 <- cutree(d.prim7.dend, k=9)\n> glyph_color(gd)[clust9==1] <- 9 # highlight triangle\n> glyph_color(gd)[clust9==1] <- 1 # reset color\n> glyph_color(gd)[clust9==2] <- 9 # highlight cluster 2\nThe top three plots show, respectively, clusters 1, 2, and 3: These clusters roughly divide the main triangular section of the data into three. The bottom row of plots show clusters labeled 5, and 6, which lie along the linear pieces, and cluster 7, which is a singleton cluster corresponding to an outlier in the data.\nThe results are reasonably easy to interpret. Recall that the basic geometry underlying this data is that there is a 2D triangle with two linear strands extending from each vertex. The hierarchical average linkage clustering of the particle physics data using nine clusters essentially divides the data into three chunks in the neighborhood of each vertex (clusters 1, 2, and 3), three pieces at the ends of the six linear strands (4, 5, and 6), and three clusters containing outliers (7, 8, and 9). This data provides a big challenge for any cluster algorithm - low-dimensional pieces embedded in high-dimensional space - and we are not surprised that no algorithm that we have tried will extract the structure we found using interactive tools.\nThe particle physics dataset is ill-suited to hierarchical clustering, but this extreme failure is an example of a common problem. When performing cluster analysis, we want to group the observations into clusters without knowing the distribution of the data. How many clusters are appropriate? What do the clusters look like? Could we just as confidently divide the data in several different ways and get very different but equally valid interpretations? Graphics can help us assess the results of a cluster analysis by helping us explore the distribution of the data and the characteristics of the clusters.\n\n\n\n\n\nBoehmke, B., and B. M. Greenwell. 2019. Hands-on Machine Learning with r (1st Ed.). Chapman; Hall/CRC. https://doi.org/10.1201/9780367816377."
  },
  {
    "objectID": "hierarchical-clustering.html#overview",
    "href": "hierarchical-clustering.html#overview",
    "title": "8  Hierarchical clustering",
    "section": "8.1 Overview",
    "text": "8.1 Overview\nHierarchical cluster algorithms sequentially fuse neighboring points to form ever-larger clusters, starting from a full interpoint distance matrix. Figure 8.1 illustrates the hierarchical clustering approach for a simple simulated data set (a) with two well-separated clusters in 2D. The dendrogram (b) is a representation of the order that points are joined into clusters. The dendrogram strongly indicates two clusters because there are two branches branches representing the last join are much longer than all of the other branches. Although, the dendrogram is usually a good summary of the steps taken by the algorithm, it can be misleading. The dendrogram might strongly suggest a clustering but it might be a terrible solution. To check this we need to show the model with the data, as shown in plot (c). The segments show how the points and clusters are joined. Note that once points are joined into a cluster, the centroid of that cluster is used as the join location with other points or other clusters, and this is represented by a “+”. We can see that the longest edge is the one stretching across the gap between the two clusters, which is the location where the dendrogram would be cut to produce the two-cluster solution. This two-cluster solution is shown in plot (d).\n\n\nCode\nlibrary(ggplot2)\nlibrary(mulgar)\nlibrary(ggdendro)\nlibrary(dplyr)\nlibrary(patchwork)\nlibrary(palmerpenguins)\nlibrary(tourr)\nlibrary(plotly)\nlibrary(htmlwidgets)\n\n\n\n\nCode\ndata(simple_clusters)\n# Data has two well-separated clusters\npd <- ggplot(simple_clusters, aes(x=x1, y=x2)) +\n  geom_point(colour=\"orange\", size=2, alpha=0.8) +\n  ggtitle(\"(a)\") +\n  theme(aspect.ratio=1) \n\n# Compute hierarchical clustering with Ward's linkage\ncl_hw <- hclust(dist(simple_clusters[,1:2]),\n                method=\"ward.D2\")\ncl_ggd <- dendro_data(cl_hw, type = \"triangle\")\nph <- ggplot() +\n  geom_segment(data=cl_ggd$segments, \n               aes(x = x, y = y, \n                   xend = xend, yend = yend)) + \n  geom_point(data=cl_ggd$labels, aes(x=x, y=y),\n             colour=\"orange\", alpha=0.8) +\n  ggtitle(\"(b)\") +\n  theme_dendro()\n\n# Compute dendrogram in data\ncl_hfly <- hierfly(simple_clusters, cl_hw, scale=FALSE)\n\npdh <- ggplot() +\n  geom_segment(data=cl_hfly$segments, \n                aes(x=x, xend=xend,\n                    y=y, yend=yend)) +\n  geom_point(data=cl_hfly$data, \n             aes(x=x1, y=x2,\n                 shape=factor(node),\n                 colour=factor(node),\n                 size=1-node), alpha=0.8) +\n  scale_shape_manual(values = c(16, 3)) +\n  scale_colour_manual(values = c(\"orange\", \"black\")) +\n  scale_size(limits=c(0,17)) +\n  ggtitle(\"(c)\") +\n  theme(aspect.ratio=1, legend.position=\"none\")\n\n# Show result\nsimple_clusters <- simple_clusters %>%\n  mutate(clw = factor(cutree(cl_hw, 2)))\npc <- ggplot(simple_clusters) +\n  geom_point(aes(x=x1, y=x2, colour=clw), \n             size=2, alpha=0.8) +\n  scale_colour_brewer(palette=\"Set1\") +\n  ggtitle(\"(d)\") +\n  theme(aspect.ratio=1, legend.position=\"none\")\n\npd + ph + pdh + pc + plot_layout(ncol=2)\n\n\n\n\n\nFigure 8.1: Hierarchical clustering on simulated data: (a) data, (b) dendrogram, (c) dendrogram on the data, and (d) two cluster solution. Nodes of the dendrogram indicated by + when it is drawn on the data.\n\n\n\n\nClustering algorithms are all prone to being confused by different problems occurring in data. For hierarchical clustering, plotting the dendrogram on the data provides another way to assess the solution. For hierarchical clustering additional the complications arise from a range of choices for defining distance once points have been joined into clusters.\nDistance between clusters is described by a “linkage method”, of which there are many. For example, single linkage measures the distance between clusters by the smallest interpoint distance between the members of the two clusters clusters, complete linkage uses the maximum interpoint distance, and average linkage uses the average of the interpoint distances. Wards linkage, which usually produces the best clustering solutions, defines the distance as the reduction in the within-group variance. A good discussion on cluster analysis and linkage can be found in Boehmke and Greenwell (2019), on Wikipedia or any multivariate textbook."
  },
  {
    "objectID": "hierarchical-clustering.html#what-can-go-wrong",
    "href": "hierarchical-clustering.html#what-can-go-wrong",
    "title": "8  Hierarchical clustering",
    "section": "8.2 What can go wrong",
    "text": "8.2 What can go wrong\n\n\nCode\n# Nuisance observations\nset.seed(20190514)\nx <- (runif(20)-0.5)*4\ny <- x\nd1 <- data.frame(x1 = c(rnorm(50, -3), \n                            rnorm(50, 3), x),\n                 x2 = c(rnorm(50, -3), \n                            rnorm(50, 3), y),\n                 cl = factor(c(rep(\"A\", 50), \n                             rep(\"B\", 70))))\nd1 <- d1 %>% \n  mutate_if(is.numeric, function(x) (x-mean(x))/sd(x))\npd1 <- ggplot(data=d1, aes(x=x1, y=x2)) + \n  geom_point() +\n    ggtitle(\"Nuisance observations\") +\n    theme(aspect.ratio=1) \n\n# Nuisance variables\nset.seed(20190512)\nd2 <- data.frame(x1=c(rnorm(50, -4), \n                            rnorm(50, 4)),\n                 x2=c(rnorm(100)),\n                 cl = factor(c(rep(\"A\", 50), \n                             rep(\"B\", 50))))\nd2 <- d2 %>% \n  mutate_if(is.numeric, function(x) (x-mean(x))/sd(x))\npd2 <- ggplot(data=d2, aes(x=x1, y=x2)) + \n  geom_point() +\n    ggtitle(\"Nuisance variables\") +\n    theme(aspect.ratio=1)\n\npd1 + pd2 + plot_layout(ncol=2)\n\n\n\n\n\nFigure 8.2: Two examples of data structure that causes problems for hierarchical clustering. Nuisance observations can cause problems because the close observations between the two clusters can cause some chaining in the hierarchical joining of observations. Nuisance variables can cause problems because observations across the gap can seem closer than observations at the end of each cluster.\n\n\n\n\n\n\nCode\n# Compute single linkage\nd1_hs <- hclust(dist(d1[,1:2]),\n                method=\"single\")\nd1_ggds <- dendro_data(d1_hs, type = \"triangle\")\npd1s <- ggplot() +\n  geom_segment(data=d1_ggds$segments, \n               aes(x = x, y = y, \n                   xend = xend, yend = yend)) + \n  geom_point(data=d1_ggds$labels, aes(x=x, y=y),\n             colour=\"orange\", alpha=0.8) +\n  ggtitle(\"(a) Single linkage dendrogram\") +\n  theme_dendro()\n\n# Compute dendrogram in data\nd1_hflys <- hierfly(d1, d1_hs, scale=FALSE)\n\npd1hs <- ggplot() +\n  geom_segment(data=d1_hflys$segments, \n                aes(x=x, xend=xend,\n                    y=y, yend=yend)) +\n  geom_point(data=d1_hflys$data, \n             aes(x=x1, y=x2,\n                 shape=factor(node),\n                 colour=factor(node),\n                 size=1-node), alpha=0.8) +\n  scale_shape_manual(values = c(16, 3)) +\n  scale_colour_manual(values = c(\"orange\", \"black\")) +\n  scale_size(limits=c(0,17)) +\n  ggtitle(\"(b) Dendrogram in data\") +\n  theme(aspect.ratio=1, legend.position=\"none\")\n\n# Show result\nd1 <- d1 %>%\n  mutate(cls = factor(cutree(d1_hs, 2)))\npc_d1s <- ggplot(d1) +\n  geom_point(aes(x=x1, y=x2, colour=cls), \n             size=2, alpha=0.8) +\n  scale_colour_brewer(palette=\"Set1\") +\n  ggtitle(\"(c) Two-cluster solution\") +\n  theme(aspect.ratio=1, legend.position=\"none\")\n\n# Compute Wards linkage\nd1_hw <- hclust(dist(d1[,1:2]),\n                method=\"ward.D2\")\nd1_ggdw <- dendro_data(d1_hw, type = \"triangle\")\npd1w <- ggplot() +\n  geom_segment(data=d1_ggdw$segments, \n               aes(x = x, y = y, \n                   xend = xend, yend = yend)) + \n  geom_point(data=d1_ggdw$labels, aes(x=x, y=y),\n             colour=\"orange\", alpha=0.8) +\n  ggtitle(\"(d) Ward's linkage dendrogram\") +\n  theme_dendro()\n\n# Compute dendrogram in data\nd1_hflyw <- hierfly(d1, d1_hw, scale=FALSE)\n\npd1hw <- ggplot() +\n  geom_segment(data=d1_hflyw$segments, \n                aes(x=x, xend=xend,\n                    y=y, yend=yend)) +\n  geom_point(data=d1_hflyw$data, \n             aes(x=x1, y=x2,\n                 shape=factor(node),\n                 colour=factor(node),\n                 size=1-node), alpha=0.8) +\n  scale_shape_manual(values = c(16, 3)) +\n  scale_colour_manual(values = c(\"orange\", \"black\")) +\n  scale_size(limits=c(0,17)) +\n  ggtitle(\"(e) Dendrogram in data\") +\n  theme(aspect.ratio=1, legend.position=\"none\")\n\n# Show result\nd1 <- d1 %>%\n  mutate(clw = factor(cutree(d1_hw, 2)))\npc_d1w <- ggplot(d1) +\n  geom_point(aes(x=x1, y=x2, colour=clw), \n             size=2, alpha=0.8) +\n  scale_colour_brewer(palette=\"Set1\") +\n  ggtitle(\"(f) Two-cluster solution\") +\n  theme(aspect.ratio=1, legend.position=\"none\")\n\npd1s + pd1hs + pc_d1s + \n  pd1w + pd1hw + pc_d1w +\n  plot_layout(ncol=3)\n\n\n\n\n\nFigure 8.3: Single linkage clustering on nuisance cases in comparison to Ward’s linkage.\n\n\n\n\n\n\nCode\n# Compute complete linkage\nd2_hc <- hclust(dist(d2[,1:2]),\n                method=\"complete\")\nd2_ggdc <- dendro_data(d2_hc, type = \"triangle\")\npd2c <- ggplot() +\n  geom_segment(data=d2_ggdc$segments, \n               aes(x = x, y = y, \n                   xend = xend, yend = yend)) + \n  geom_point(data=d2_ggdc$labels, aes(x=x, y=y),\n             colour=\"orange\", alpha=0.8) +\n  ggtitle(\"(a) Complete linkage dendrogram\") +\n  theme_dendro()\n\n# Compute dendrogram in data\nd2_hflyc <- hierfly(d2, d2_hc, scale=FALSE)\n\npd2hc <- ggplot() +\n  geom_segment(data=d2_hflyc$segments, \n                aes(x=x, xend=xend,\n                    y=y, yend=yend)) +\n  geom_point(data=d2_hflyc$data, \n             aes(x=x1, y=x2,\n                 shape=factor(node),\n                 colour=factor(node),\n                 size=1-node), alpha=0.8) +\n  scale_shape_manual(values = c(16, 3)) +\n  scale_colour_manual(values = c(\"orange\", \"black\")) +\n  scale_size(limits=c(0,17)) +\n  ggtitle(\"(b) Dendrogram in data\") +\n  theme(aspect.ratio=1, legend.position=\"none\")\n\n# Show result\nd2 <- d2 %>%\n  mutate(clc = factor(cutree(d2_hc, 2)))\npc_d2c <- ggplot(d2) +\n  geom_point(aes(x=x1, y=x2, colour=clc), \n             size=2, alpha=0.8) +\n  scale_colour_brewer(palette=\"Set1\") +\n  ggtitle(\"(c) Two-cluster solution\") +\n  theme(aspect.ratio=1, legend.position=\"none\")\n\n# Compute Wards linkage\nd2_hw <- hclust(dist(d2[,1:2]),\n                method=\"ward.D2\")\nd2_ggdw <- dendro_data(d2_hw, type = \"triangle\")\npd2w <- ggplot() +\n  geom_segment(data=d2_ggdw$segments, \n               aes(x = x, y = y, \n                   xend = xend, yend = yend)) + \n  geom_point(data=d2_ggdw$labels, aes(x=x, y=y),\n             colour=\"orange\", alpha=0.8) +\n  ggtitle(\"(d) Ward's linkage dendrogram\") +\n  theme_dendro()\n\n# Compute dendrogram in data\nd2_hflyw <- hierfly(d2, d2_hw, scale=FALSE)\n\npd2hw <- ggplot() +\n  geom_segment(data=d2_hflyw$segments, \n                aes(x=x, xend=xend,\n                    y=y, yend=yend)) +\n  geom_point(data=d2_hflyw$data, \n             aes(x=x1, y=x2,\n                 shape=factor(node),\n                 colour=factor(node),\n                 size=1-node), alpha=0.8) +\n  scale_shape_manual(values = c(16, 3)) +\n  scale_colour_manual(values = c(\"orange\", \"black\")) +\n  scale_size(limits=c(0,17)) +\n  ggtitle(\"(e) Dendrogram in data\") +\n  theme(aspect.ratio=1, legend.position=\"none\")\n\n# Show result\nd2 <- d2 %>%\n  mutate(clw = factor(cutree(d2_hw, 2)))\npc_d2w <- ggplot(d2) +\n  geom_point(aes(x=x1, y=x2, colour=clw), \n             size=2, alpha=0.8) +\n  scale_colour_brewer(palette=\"Set1\") +\n  ggtitle(\"(f) Two-cluster solution\") +\n  theme(aspect.ratio=1, legend.position=\"none\")\n\npd2c + pd2hc + pc_d2c + \n  pd2w + pd2hw + pc_d2w +\n  plot_layout(ncol=3)\n\n\n\n\n\nFigure 8.4: Complete linkage clustering on nuisance variables in comparison to Ward’s linkage. The complete linkage dendrogram looks quite reasonably suggesting a two-cluster solution, but when it is plotted amongst the data that it is clearly not a good two-cluster solution."
  },
  {
    "objectID": "hierarchical-clustering.html#clustering-in-high-dimensions",
    "href": "hierarchical-clustering.html#clustering-in-high-dimensions",
    "title": "8  Hierarchical clustering",
    "section": "8.3 Clustering in high-dimensions",
    "text": "8.3 Clustering in high-dimensions\nCheck the data: pretend we don’t know the clusters. Think you can see three elliptical clusters. One is further from the others.\n\n\nCode\npenguins <- penguins %>%\n  na.omit() # 11 observations out of 344 removed\n# use only vars of interest, and standardise\n# them for easier interpretation\npenguins_cl <- penguins[,c(1, 3:6)] %>% \n  mutate(across(where(is.numeric),  ~\n                  mulgar:::scale2(.))) %>%\n  rename(bl = bill_length_mm,\n         bd = bill_depth_mm,\n         fl = flipper_length_mm,\n         bm = body_mass_g) %>%\n  select(bl, bd, fl, bm, species) %>%\n  as.data.frame()\n\n\n\nset.seed(20230329)\nb <- basis_random(4,2)\npt1 <- save_history(penguins_cl[,1:4], \n                    max_bases = 500, \n                    start = b)\nsave(pt1, file=\"data/penguins_tour_path.rda\")\nanimate_xy(penguins_cl[,1:4], \n           tour_path = planned_tour(pt1), \n           axes=\"off\", rescale=FALSE, \n           half_range = 3.5)\n\n\n\nCode\nload(\"data/penguins_tour_path.rda\")\nrender_gif(penguins_cl[,1:4], \n           planned_tour(pt1), \n           display_xy(half_range=0.9, axes=\"off\"),\n           gif_file=\"gifs/penguins_gt.gif\",\n           frames=500,\n           loop=FALSE)\n\n\n\n\n\nFigure 8.5: Grand tour of the penguins data\n\n\n\n\nCode\np_dist <- dist(penguins_cl[,1:4])\np_hcw <- hclust(p_dist, method=\"ward.D2\")\np_hcs <- hclust(p_dist, method=\"single\")\n\np_clw <- penguins_cl %>% mutate(cl = factor(cutree(p_hcw, 3)))\np_cls <- penguins_cl %>% mutate(cl = factor(cutree(p_hcs, 3)))\n\np_w_hfly <- hierfly(p_clw, p_hcw, scale=FALSE)\np_s_hfly <- hierfly(p_cls, p_hcs, scale=FALSE)\n\n\n\n\nCode\nload(\"data/penguins_tour_path.rda\")\n# library(RColorBrewer)\n#pal <- brewer.pal(length(unique(p_w_hfly$data$cl)), \"Set2\")\n#colw <- pal[p_w_hfly$data$cl]\n#cols <- pal[p_s_hfly$data$cl]\nglyphs <- c(16, 46)\npchw <- glyphs[p_w_hfly$data$node+1]\npchs <- glyphs[p_s_hfly$data$node+1]\n\nanimate_xy(p_w_hfly$data[,1:4], \n           #col=colw, \n           tour_path = planned_tour(pt1),\n           pch = pchw,\n           edges=p_w_hfly$edges, \n           axes=\"bottomleft\")\n\nanimate_xy(p_s_hfly$data[,1:4], \n           #col=colw, \n           tour_path = planned_tour(pt1),\n           pch = pchs,\n           edges=p_s_hfly$edges, \n           axes=\"bottomleft\")\n\nrender_gif(p_w_hfly$data[,1:4], \n           planned_tour(pt1),\n           display_xy(half_range=0.9,            \n                      pch = pchw,\n                      edges = p_w_hfly$edges,\n                      axes = \"off\"),\n           gif_file=\"gifs/penguins_hflyw.gif\",\n           frames=500,\n           loop=FALSE)\n\nrender_gif(p_s_hfly$data[,1:4], \n           planned_tour(pt1), \n           display_xy(half_range=0.9,            \n                      pch = pchs,\n                      edges = p_s_hfly$edges,\n                      axes = \"off\"),\n           gif_file=\"gifs/penguins_hflys.gif\",\n           frames=500,\n           loop=FALSE)\n\n\n\n\n\nFigure 8.6: Dendrogram for Wards linkage of the penguins data\n\n\n\n\n\nFigure 8.7: Dendrogram for single linkage of the penguins data\n\n\n\n\nCode\nload(\"data/penguins_tour_path.rda\")\n# Create a smaller one, for space concerns\npt1i <- interpolate(pt1[,,1:5], 0.1)\npw_anim <- render_anim(p_w_hfly$data, vars=1:4,\n                         frames=pt1i, \n                       edges = p_w_hfly$edges,\n             obs_labels=paste0(1:nrow(p_w_hfly$data),\n                               p_w_hfly$data$cl))\n\npw_gp <- ggplot() +\n     #geom_path(data=pw_anim$circle, \n     #          aes(x=c1, y=c2,\n     #              frame=frame), linewidth=0.1) +\n     #geom_segment(data=pw_anim$axes, \n     #             aes(x=x1, y=y1, \n     #                 xend=x2, yend=y2, \n     #                 frame=frame), \n     #             linewidth=0.1) +\n     #geom_text(data=pw_anim$axes, \n     #          aes(x=x2, y=y2, \n     #              frame=frame, \n     #              label=axis_labels), \n     #          size=5) +\n     geom_segment(data=pw_anim$edges, \n                    aes(x=x, xend=xend,\n                        y=y, yend=yend,\n                        frame=frame)) +\n     geom_point(data=pw_anim$frames, \n                aes(x=P1, y=P2, \n                    frame=frame, \n                    shape=factor(node),\n                    label=obs_labels), \n                alpha=0.8, size=1) +\n     xlim(-1,1) + ylim(-1,1) +\n     scale_shape_manual(values=c(16, 46)) +\n     coord_equal() +\n     theme_bw() +\n     theme(legend.position=\"none\", \n           axis.text=element_blank(),\n           axis.title=element_blank(),\n           axis.ticks=element_blank(),\n           panel.grid=element_blank())\n\npwg <- ggplotly(pw_gp, width=450, height=500) %>%\n       animation_button(label=\"Go\") %>%\n       animation_slider(len=0.8, x=0.5,\n                        xanchor=\"center\") %>%\n       animation_opts(easing=\"linear\", transition = 0)\nhtmlwidgets::saveWidget(pwg,\n          file=\"html/penguins_cl_ward.html\",\n          selfcontained = TRUE)\n\n# Single\nps_anim <- render_anim(p_s_hfly$data, vars=1:4,\n                         frames=pt1i, \n                       edges = p_s_hfly$edges,\n             obs_labels=paste0(1:nrow(p_s_hfly$data),\n                               p_s_hfly$data$cl))\n\nps_gp <- ggplot() +\n     #geom_path(data=pw_anim$circle, \n     #          aes(x=c1, y=c2,\n     #              frame=frame), linewidth=0.1) +\n     #geom_segment(data=pw_anim$axes, \n     #             aes(x=x1, y=y1, \n     #                 xend=x2, yend=y2, \n     #                 frame=frame), \n     #             linewidth=0.1) +\n     #geom_text(data=pw_anim$axes, \n     #          aes(x=x2, y=y2, \n     #              frame=frame, \n     #              label=axis_labels), \n     #          size=5) +\n     geom_segment(data=ps_anim$edges, \n                    aes(x=x, xend=xend,\n                        y=y, yend=yend,\n                        frame=frame)) +\n     geom_point(data=ps_anim$frames, \n                aes(x=P1, y=P2, \n                    frame=frame, \n                    shape=factor(node),\n                    label=obs_labels), \n                alpha=0.8, size=1) +\n     xlim(-1,1) + ylim(-1,1) +\n     scale_shape_manual(values=c(16, 46)) +\n     coord_equal() +\n     theme_bw() +\n     theme(legend.position=\"none\", \n           axis.text=element_blank(),\n           axis.title=element_blank(),\n           axis.ticks=element_blank(),\n           panel.grid=element_blank())\n\npsg <- ggplotly(ps_gp, width=450, height=500) %>%\n       animation_button(label=\"Go\") %>%\n       animation_slider(len=0.8, x=0.5,\n                        xanchor=\"center\") %>%\n       animation_opts(easing=\"linear\", transition = 0)\nhtmlwidgets::saveWidget(psg,\n          file=\"html/penguins_cl_single.html\",\n          selfcontained = TRUE)\n\n\n\n\n\nFigure 8.8: Animation of dendrogram from Wards linkage clustering of the penguins data.\n\n\n\n\n\nFigure 8.9: Animation of dendrogram from single linkage clustering of the penguins data.\n\n\n\n\n\n\n\nBoehmke, B., and B. M. Greenwell. 2019. Hands-on Machine Learning with r (1st Ed.). Chapman; Hall/CRC. https://doi.org/10.1201/9780367816377."
  },
  {
    "objectID": "pca.html#exercises",
    "href": "pca.html#exercises",
    "title": "2  Principal component analysis (PCA)",
    "section": "2.1 Exercises",
    "text": "2.1 Exercises\n\nMake a scatterplot matrix of the first four PCs. Is the branch pattern visible in any pair?\nConstruct five new variables to measure these skills offense, defense, playing time, ball movement, errors. Using the tour, examine the relationship between these variables. Map out how a few players could be characterised based on these directions of skills."
  },
  {
    "objectID": "model-based-clustering.html",
    "href": "model-based-clustering.html",
    "title": "10  Model-based clustering",
    "section": "",
    "text": "Model-based clustering Fraley and Raftery (2002) fits a multivariate normal mixture model to the data. It uses the EM algorithm to fit the parameters for the mean, variance–covariance of each population, and the mixing proportion. The variance–covariance matrix is re-parametrized using an eigen-decomposition\n[ _k = _kD_kA_kD_k’, ~~~k=1, , g ~~ ]\nresulting in several model choices, ranging from simple to complex:\n\nNote the distribution descriptions “spherical” and “ellipsoidal”. These are descriptions of the shape of the variance–covariance for a multivariate normal distribution. A standard multivariate normal distribution has a variance–covariance matrix with zeros in the off-diagonal elements, which corresponds to spherically shaped data. When the variances (diagonals) are different or the variables are correlated, then the shape of data from a multivariate normal is ellipsoidal.\n\n\nThe models are typically scored using the Bayes Information Criterion (BIC), which is based on the log likelihood, number of variables, and number of mixture components. They should also be assessed using graphical methods, as we demonstrate using the data. We start with two of the five real-valued variables ( and ) and one (Blue).\n> library(mclust)\n> d.crabs <- read.csv(\"australian-crabs.csv\")\n> d.blue.crabs <- subset(d.crabs,\n    species==\"Blue\", select=c(sex,FL:BD))\nThe goal is to determine whether model-based methods can discover clusters that will distinguish between the two sexes.\n\n?fig-model-based1 contains the plots we will use to examine the results of model-based clustering on this reduced dataset. The top leftmost plot shows the data, with male and female crabs distinguished by color and glyph. The two sexes correspond to long cigar-shaped objects that overlap a bit, particularly for smaller crabs. The “cigars” are not perfectly regular: The variance of the data is smaller at small values for both sexes, so that our cigars are somewhat wedge-shaped. The orientation of the longest direction of variance differs slightly between groups too: The association has a steeper slope for female crabs than for males, because female crabs have relatively larger rear width than male crabs. With the heterogeneity in variance–covariance, this data does not strictly adhere to the multivariate normal mixture model underlying model-based methods, but we hope that the departure from regularity is not so extreme that it prevents the model from working.\nThe top right plot shows the BIC results for a full range of models, EEE, EEV, and VVV variance-covariance parametrization for one to nine clusters:\n> blue.crabBIC <- mclustBIC(subset(d.blue.crabs,\n    select=c(FL,RW)), modelNames=c(\"EEE\",\"EEV\",\"VVV\"))\n> blue.crabBIC\n BIC:\n        EEE       EEV       VVV\n1 -810.3289 -810.3289 -810.3289\n2 -820.7272 -778.6450 -783.7705\n3 -832.7712 -792.5937 -821.8645\n4 -824.8927 -835.5631 -835.7799\n5 -805.8402 -805.9425 -853.1395\n6 -807.8380 -821.1586 -879.3500\n7 -827.1099 -860.7258 -878.0679\n8 -833.8051 -861.1460 -891.9757\n9 -835.6620 -854.6120 -904.6108\n> plot(blue.crabBIC)\nEEE EEV VVV \n 15  12   0 \nThe best model, EEV-2, used the equal volume, equal shape, and different orientation variance–covariance parametrization and divided the data into two clusters. This solution seems to be perfect! We can imagine that this result corresponds to two equally shaped ellipses that intersect near the lowest values of the data and angle toward higher values. We will check by drawing ellipses representing the variance–covariance parametrization on the data plots. The parameter estimates are used to scale and center the ellipses:\n> mclst1 <- mclustBIC(subset(d.blue.crabs,\n    select=c(FL,RW)), G=2, modelNames=\"EEV\")\n> mclst1\n BIC:\n       EEV\n2 -778.645\n> smry1 <- mclustModel(subset(d.blue.crabs,\n    select=c(FL,RW)), mclst1, G=2, modelNames=\"EEV\")\n> vc <- smry1$parameters$variance$sigma[,,1]\n> xm <- smry1$parameters$mean[,1]\n> y1 <- f.vc.ellipse(vc,xm,500)\n> ...\nyielding the plots in the middle and bottom rows of ?fig-model-based1. In the plot of the data alone, cluster id is used for the color and glyph of points. (Compare this plot with the one directly above it, in which the classes are known.) Cluster 1 mostly corresponds to the female crabs, and cluster 2 to the males, except that all the small crabs, both male and female, have been assigned to cluster 1. In the rightmost plot, we have added ellipses representing the estimated variance–covariances. The ellipses are the same shape, as specified by the model, but the ellipse for cluster 2 is shifted toward the large values.\nThe next two best models, according to the BIC values, are EEV-3 and VVV-2. The plots in the bottom row display representations of the variance–covariances for these models. EEV-3 organizes the crabs into three clusters according to the size, not the sex, of the crabs. The VVV-2 solution is similar to EEV-2.\nWhat solution is the best for this data? If the EEV-3 model had done what we intuitively expected, it would have been ideal: The sexes of smaller crabs are indistinguishable, so they should be afforded their own cluster, whereas larger crabs could be clustered into males and females. However, the cluster that includes the small crabs also includes a fair number of middle-sized female crabs.\nFinally, model-based clustering did not discover the true gender clusters. Still, it produced a useful and interpretable clustering of the crabs.\nPlots are indispensable for choosing an appropriate cluster model. It is easy to visualize the models when there are only two variables but increasingly difficult as the number of variables grows. Tour methods save us from producing page upon page of plots. They allow us to look at many projections of the data, which enables us to conceptualize the shapes and relationships between clusters in more than two dimensions.\n?fig-model-based2 displays the graphics for the corresponding high-dimensional investigation using all five variables and four classes (two species, two sexes) of the . The cluster analysis is much more difficult now. Can model-based clustering uncover these four groups?\nIn the top row of plots, we display the raw data, before modeling. Each plot is a tour projection of the data, colored according to the four true classes. The blue and purple points are the male and female crabs of the blue species, and the yellow and orange points are the male and female crabs of the orange species. This table will help you keep track:\n\nThe clusters corresponding to the classes are long thin wedges in five dimensions (5D), with more separation and more variability at larger values, as we saw in the subset just discussed. The rightmost plot shows the ``looking down the barrel’’ view of the wedges. At small values the points corresponding to the sexes are mixed (leftmost plot). The species are reasonably well separated even for small crabs (middle plot). The variance–covariance is wedge-shaped rather than elliptical, but again we hope that modeling based on the normal distribution that has elliptical variance–covariance will be adequate.\n\nIn the results from model-based clustering, there is very little difference in BIC value for variance–covariance models EEE, EEV, VEV, and VVV, with a number of clusters from three to eight. The best model is EEV-3, and EEV-4 is second best. We know that three clusters is insufficient to capture the four classes we have in mind, so we examine the four-cluster solution.\n> mclst4 <- mclustBIC(subset(d.blue.crabs,select=c(FL:BD)),\n    G=1:8, modelNames=c(\"EEE\",\"EEV\",\"VVV\"))\n> plot(mclst4)\nEEE EEV VVV \n 15  12   0 \n> mclst5 <- mclustBIC(subset(d.blue.crabs,select=c(FL:BD)), \n   G=4, modelNames=\"EEV\")\n> smry5 <- mclustModel(subset(d.blue.crabs,select=c(FL:BD)), \n   mclst5, G=4, modelNames=\"EEV\")\nThe bottom row of plots in ?fig-model-based2 illustrates the four-cluster model in three different projections, matching the projections in the top row showing the data.\n> vc <- smry5$parameters$variance$sigma[,,1]\n> mn <- smry5$parameters$mean[,1]\n> y1 <- f.vc.ellipse(vc, mn)\n> ...\n> mclst5.model <- cbind(matrix(NA,500*4,3),\n    rbind(y1,y2,y3,y4))\n> colnames(mclst5.model) <-\n    c(\"Species\",\"Sex\",\"Index\",\"FL\",\"RW\",\"CL\",\"CW\",\"BD\")\n> d.crabs.model <- rbind(d.crabs, mclst5.model)\n> gd <- ggobi(d.crabs.model)[1]\n> glyph_color(gd) <- c(rep(4,50), rep(1,50), rep(9,50), \n    rep(6,50), rep(8,2000))\nIn each view, the ellipsoids representing the variance–covariance estimates for the four clusters are shown in four shades of gray, because none of these match any actual cluster in the data. Remember that these are 2D projections of 5D ellipsoids. The resulting clusters from the model do not match the true classes very well. The result roughly captures the two species, as we see in the plots in the first column, where the species are separated both in the data and in the ellipses. On the other hand, the grouping corresponding to is completely missed: See the plots in the middle and right-hand columns, where sexes are separated in the actual data but the ellipses are not separated. Just as in the smaller subset (two variables, one species) discussed earlier, there is a cluster for the smaller crabs of both species and sexes. The results of model-based clustering on the full 5D data are very unsatisfactory.\nIn summary, plots of the data and parameter estimates for model-based cluster analysis are very useful for understanding the solution, and choosing an appropriate model. Tours are very helpful for examining the results in higher dimensions, for arbitrary numbers of variables.\n\n\n\n\n\nFraley, C., and A. E. Raftery. 2002. “Model-Based Clustering, Discriminant Analysis, Density Estimation.” Journal of the American Statistical Association 97: 611–31."
  }
]