# Support vector machines
\index{classification methods!support vector machines (SVM)}

A support vector machine (SVM) [@Va99] looks for gaps between clusters in the data, based on the extreme observations in each class. In this sense it mirrors the graphical approach described @sec-clust-graphics, in which we searched for gaps between groups. It can be viewed as similar to LDA, in that the boundary between classes is a hyperplane.  The difference between LDA and SVM is the placement of the boundary. LDA uses the means and covariance matrices of the classes to place the boundary, but SVM uses extreme observations.

::: info
The key elements of the SVM model to examine are:

- support vectors
- separating hyperplane.

:::

SVM is widely used for it's ability to fit non-linear classification models in a simple fashion using kernels in the boundary equation. We are focusing on linear methods here because it makes for a useful comparison with how the models differ from those provided by SVM. SVM tends to place the boundary between groups in a gap, if it exists. This is nice from a visual perspective because when we look at differences between classes using a tour, we naturally focus on the gaps. SVM better fits this perception than LDA. 

Non-linear SVM models are interesting to examine also. Mostly one would examine the boundaries between classes which can be done in the same way that is documented in the @sec-lda and @sec-trees-forests.

## Components of the SVM model

To illustrate the approach, we use two simple simulated data examples. Both have only two variables, and two classes. Explaining SVM is easier when there are just two groups. In the first data set the two classes have different covariances matrices, which will cause trouble for LDA, but SVM should see the gap between the two clusters and place the separating hyperplane in the middle of the gap. In the second data set the two groups are concentric circles, with the inner one solid. A non-linear SVM should be fitted to this data, which should see circular gap between the two classes. 

Note that the `svm` function in the `e1071` package will automatically scale observations into the range $[0,1]$. To make it easier to examine the fitted model, it is best to scale your data first, and then fit the model.

```{r}
#| code-summary: "Code to simulate data examples"
# Toy examples
library(mulgar)
library(ggplot2)
library(geozoo)
library(tourr)

set.seed(1071)
n1 <- 162
vc1 <- matrix(c(1, -0.7, -0.7, 1), ncol=2, byrow=TRUE)
c1 <- rmvn(n=n1, p=2, mn=c(-2, -2), vc=vc1)
vc2 <- matrix(c(1, -0.4, -0.4, 1)*2, ncol=2, byrow=TRUE)
n2 <- 138
c2 <- rmvn(n=n2, p=2, mn=c(2, 2), vc=vc2)
df1 <- data.frame(x1=mulgar:::scale2(c(c1[,1], c2[,1])), 
                 x2=mulgar:::scale2(c(c1[,2], c2[,2])), 
                 cl = factor(c(rep("A", n1), 
                               rep("B", n2))))
c1 <- sphere.hollow(p=2, n=n1)$points*3 + 
  c(rnorm(n1, sd=0.3), rnorm(n1, sd=0.3))
c2 <- sphere.solid.random(p=2, n=n2)$points
df2 <- data.frame(x1=mulgar:::scale2(c(c1[,1], c2[,1])), 
                  x2=mulgar:::scale2(c(c1[,2], c2[,2])), 
                  cl = factor(c(rep("A", n1), 
                               rep("B", n2))))
```

```{r}
#| code-fold: false
#| message: false
library(classifly)
library(e1071)
df1_svm <- svm(cl~., data=df1, 
                     probability=TRUE, 
                     kernel="linear", 
               scale=FALSE)
df1_svm_e <- explore(df1_svm, df1)

df2_svm <- svm(cl~., data=df2,  
                     probability=TRUE, 
                     kernel="radial")
df2_svm_e <- explore(df2_svm, df2)
```

```{r}
#| label: fig-svm-toy
#| fig-cap: "SVM classifier fit overlaid on two simulated data examples: (a) groups with different variance-covariance, fitted using a linear kernel, (b) groups with non-linear separation, fitted using a radial kernel. The band of points shown as '+' mark the SVM boundary, and points marked by 'x' are the support vectors used to define the boundary. "
#| fig-width: 8
#| fig-height: 4
#| code-summary: "Code to make plots"
library(patchwork)
library(colorspace)
s1 <- ggplot() + 
  geom_point(data=df1, aes(x=x1, y=x2, colour=cl),
             shape=20) +
  scale_colour_discrete_divergingx(palette="Zissou 1") +
  geom_point(data=df1_svm_e[(!df1_svm_e$.BOUNDARY)&(df1_svm_e$.TYPE=="simulated"),], 
             aes(x=x1, y=x2, colour=cl), shape=3) +
  geom_point(data=df1[df1_svm$index,], 
             aes(x=x1, y=x2, colour=cl), 
             shape=4, size=4) +
  theme_minimal() +
  theme(aspect.ratio=1, legend.position = "none") +
  ggtitle("(a)")

s2 <- ggplot() + 
  geom_point(data=df2, aes(x=x1, y=x2, colour=cl), shape=20) +
  scale_colour_discrete_divergingx(palette="Zissou 1") +
  geom_point(data=df2_svm_e[(!df2_svm_e$.BOUNDARY)&(df2_svm_e$.TYPE=="simulated"),], 
             aes(x=x1, y=x2, colour=cl), 
             shape=3) +
  geom_point(data=df2[df2_svm$index,], 
             aes(x=x1, y=x2, colour=cl), 
             shape=4, size=4) +
  theme_minimal() +
  theme(aspect.ratio=1, legend.position = "none") +
  ggtitle("(b)")

s1+s2
```

@fig-svm-toy shows the two data sets and the important aspects of the fitted SVM model for each. The observations are represented by dots, the separating hyperplane (just a line for 2D) is represented by '+'. Where the two colours merge is the actual location of the boundary between classes. It can be seen that this is located right down the middle of the gap, for both data sets. Even though the boundary is circular for the second data set, in a transformed high-dimensional space it would be linear.

SVMs use a subset of the observations to define the boundary, and these are called the support vectors. For each of the data sets these are marked with 'x'. For the linear boundary, there are nine support vectors, five in one group and four in the other. There is one interesting observation in the red group, which falls on the other side of the boundary. It is marked as a support vector, but its contribution to the fitted hyperplane is limited by a control parameter in the model fitting process. 

Linear SVMs can be assessed similarly to regression models. The components of the model are:

1. The points that are the support vectors:

```{r}
#| code-fold: false
df1_svm$index
```

2. Their coefficients:

```{r}
#| code-fold: false
df1_svm$coefs
```

which indicate that all but 15, 45 and 180 are actually bounded support vectors (their coefficients are bounded to magnitude 1). 

3. that when used with the intercept:

```{r}
#| code-fold: false
df1_svm$rho
```

can be used to compute the equation of the fitted hyperplane. 

```{r}
#| code-fold: false
w = t(df1_svm$SV) %*% df1_svm$coefs
w
```

Giving the equation to be `r round(w[1], 2)` $x_1 +$ `r round(w[2], 2)` $x_2 +$ `r round(-df1_svm$rho, 2)` $=0$, or alternatively, $x_2 =$ `r round(-w[1]/w[2], 2)` $x_1 +$ `r round(df1_svm$rho/w[2], 2)`.

which can be used to generate a line to show the boundary with the data. 

```{r}
#| eval: false
#| code-fold: false
s1 + geom_abline(intercept=df1_svm$rho/w[2],
                 slope=-w[1]/w[2])
```

**Note that** care in scaling of data is important to get the intercept calculated exactly. We have standardised the data, and set the `scale=FALSE` parameter in the `svm` function. The slope calculation is quite robust to the data scaling.

::: info
An SVM model is fully determined by the support vectors that fix the position of the hyperplane. To construct the plane we also need the model coefficients and these are constrained for observations on the wrong side of the margin. For a linear SVM we can extract these components and write down the equation for the hyperplane.

:::

## Examining the model components in high-dimensions

For higher dimensions, the procedures are similar, with the hyperplane and support vectors being examined using a tour. Here we examine the model for differentiating male and female Chinstrap penguins. The Chinstrap penguins have a noticeable difference in size of the sexes, unlike the other two species. Working with a two-class problem is easier for explaining SVM, but multi-class calculations can also follow this approach.

```{r}
#| code-fold: false
#| warning: false
#| message: false
library(dplyr)
load("data/penguins_sub.rda")
chinstrap <- penguins_sub %>%
  filter(species == "Chinstrap") %>%
  select(-species) %>%
  mutate_if(is.numeric, mulgar:::scale2)
chinstrap_svm <- svm(sex~., data=chinstrap, 
                     kernel="linear",
                     probability=TRUE, 
                     scale=FALSE)
chinstrap_svm_e <- explore(chinstrap_svm, chinstrap)
```

```{r}
#| eval: false
#| code-summary: "Code to make the tours"
# Tour raw data
animate_xy(chinstrap[,1:4], col=chinstrap$sex)
# Add all SVs, including bounded
c_pch <- rep(20, nrow(chinstrap))
c_pch[chinstrap_svm$index] <- 4
animate_xy(chinstrap[,1:4], col=chinstrap$sex, pch=c_pch)
# Only show the SVs with |coefs| < 1
c_pch <- rep(20, nrow(chinstrap))
c_pch[chinstrap_svm$index[abs(chinstrap_svm$coefs)<1]] <- 4
c_cex <- rep(1, nrow(chinstrap))
c_cex[chinstrap_svm$index[abs(chinstrap_svm$coefs)<1]] <- 2
animate_xy(chinstrap[,1:4], col=chinstrap$sex, 
           pch=c_pch, cex=c_cex)
render_gif(chinstrap[,1:4],
           grand_tour(),
           display_xy(col=chinstrap$sex, pch=c_pch, cex=c_cex),
           gif_file="gifs/chinstrap_svs.gif",
           width=400,
           height=400,
           frames=500)

# Tour the separating hyperplane also
symbols <- c(3, 20)
c_pch <- symbols[as.numeric(chinstrap_svm_e$.TYPE[!chinstrap_svm_e$.BOUNDARY])]
animate_xy(chinstrap_svm_e[!chinstrap_svm_e$.BOUNDARY,1:4], 
           col=chinstrap_svm_e$sex[!chinstrap_svm_e$.BOUNDARY],
           pch=c_pch)
render_gif(chinstrap_svm_e[!chinstrap_svm_e$.BOUNDARY,1:4],
           grand_tour(),
           display_xy(col=chinstrap_svm_e$sex[!chinstrap_svm_e$.BOUNDARY], pch=c_pch),
           gif_file="gifs/chinstrap_svm.gif",
           width=400,
           height=400,
           frames=500)
```

::: {#fig-p-svm layout-ncol=2}

::: {.content-hidden when-format="pdf"}
![Exploring which points are support vectors.](gifs/chinstrap_svs.gif){#fig-chinstrap_svs fig-alt="FIX ME" width=300}
:::

::: {.content-hidden when-format="pdf"}
![Exploring SVM boundary.](gifs/chinstrap_svm.gif){#fig-chinstrap_svm fig-alt="FIX ME" width=300}
:::

SVM model for distinguishing the sexes of the Chinstrap penguins. The separating hyperplane is 3D, and separates primarily on variables `bl` and `bd`, as seen because these two axes extend out from the plane when it is seen on its side, separating the two groups.
:::

Examining the hyperplane in a grand tour display indicates that two of the variables, `bl` and `bd`, are important for separating the two classes. We can check this interpretation using the radial tour. Using the components from the model, the coefficients of the hyperplane are: 


```{r}
#| code-fold: false
t(chinstrap_svm$SV) %*% chinstrap_svm$coefs
```

This supports the observation that `bl` and `bd` are most important, because they have the largest magnitudes. We can use this vector to set the starting point for radial tour. It needs to be normalised. A randomly generated second vector orthonormal to this one can be added to make a 2D projection from which to see the boundary.

```{r}
#| code-fold: false
set.seed(1022)
prj1 <- mulgar::norm_vec(t(chinstrap_svm$SV) %*%
                           chinstrap_svm$coefs)
prj2 <- basis_random(4, 1)
prj <- orthonormalise(cbind(prj1, prj2))
prj
```

```{r}
#| eval: false
#| code-summary: "Code to conduct the radial tours"
animate_xy(chinstrap_svm_e[!chinstrap_svm_e$.BOUNDARY,1:4], 
           tour_path = radial_tour(start=prj, mvar = 2),
           col=chinstrap_svm_e$sex[!chinstrap_svm_e$.BOUNDARY],
           pch=c_pch)
render_gif(chinstrap_svm_e[!chinstrap_svm_e$.BOUNDARY,1:4],
           radial_tour(start=prj, mvar = 2),
           display_xy(col=chinstrap_svm_e$sex[!chinstrap_svm_e$.BOUNDARY], pch=c_pch),
           gif_file="gifs/chinstrap_rad_bd.gif",
           apf = 1/30,
           width=400,
           height=400,
           frames=500)
render_gif(chinstrap_svm_e[!chinstrap_svm_e$.BOUNDARY,1:4],
           radial_tour(start=prj, mvar = 1),
           display_xy(col=chinstrap_svm_e$sex[!chinstrap_svm_e$.BOUNDARY], pch=c_pch),
           gif_file="gifs/chinstrap_rad_bl.gif",
           apf = 1/30,
           width=400,
           height=400,
           frames=500)
render_gif(chinstrap_svm_e[!chinstrap_svm_e$.BOUNDARY,1:4],
           radial_tour(start=prj, mvar = 3),
           display_xy(col=chinstrap_svm_e$sex[!chinstrap_svm_e$.BOUNDARY], pch=c_pch),
           gif_file="gifs/chinstrap_rad_fl.gif",
           apf = 1/30,
           width=400,
           height=400,
           frames=500)
render_gif(chinstrap_svm_e[!chinstrap_svm_e$.BOUNDARY,1:4],
           radial_tour(start=prj, mvar = 4),
           display_xy(col=chinstrap_svm_e$sex[!chinstrap_svm_e$.BOUNDARY], pch=c_pch),
           gif_file="gifs/chinstrap_rad_bm.gif",
           apf = 1/30,
           width=400,
           height=400,
           frames=500)
```

::: {#fig-chinstrap-radial layout-ncol=2}

::: {.content-hidden when-format="pdf"}
![bl](gifs/chinstrap_rad_bl.gif){#fig-chinstrap-radial-bl}
:::

::: {.content-hidden when-format="pdf"}
![bd](gifs/chinstrap_rad_bd.gif){#fig-chinstrap-radial-bd}
:::

::: {.content-hidden when-format="pdf"}
![fl](gifs/chinstrap_rad_fl.gif){#fig-chinstrap-radial-fl}
:::

::: {.content-hidden when-format="pdf"}
![bm](gifs/chinstrap_rad_bm.gif){#fig-chinstrap-radial-bm}
:::

Exploring the importance of the four variables to the separating hyperplane using a radial tour where the contribution of each variable is reduced to 0, and then increased to it's original value. You can see that `bl` and `bd` contribute most to the plane, because when they are removed the plane is no longer on it side marking the boundary. Variables `fl` and `bm` contribute a small amount to the separating hyperplane, but it is possible that these two could be removed without affecting the strength of the separation between the sexes. 
:::

::: insight
When we use the radial tour to examine how the different variables contribute to the separating hyperplane between the sexes, we learn that `bl` and `bd` are the most important variables. Very little contribution comes from `fl` and `bm`.
:::


<!-- include Distance-weighted discrimination, eg kerndwd -->


## Exercises {-}

1. Generate a small subset from the `bushfire` data: we keep the variables `log_dist_cfa`, `log_dist_road` and `cause`, and we select only observations where `cause` is either lightning or arson. Fit a linear SVM model to separate the two classes and show the decision boundary together with the data. Compare to the boundary obtained by LDA and argue how the two models place the separating hyperplane in different ways.
2. We extend this into a multivariate setting by also including `amaxt90`, `amaxt180` and `amaxt720` as predictors. Fit a linear SVM model and calculate the hyperplane to judge which of these variables are important.
3. Calculate the decision boundary and look at it with a radial tour to see the effect from including individual predictors in a projection. Also explore what happens when rotating out multiple variables together. What can you learn from this?
XXXX boundary not filled in in this setting, what is happening here?
4. From the `sketches_train` data select all observations of class banana or cactus. For this subset use PCA to find the first 9 PCs. Fit two SVM models: once with linear kernel and once with radial kernel and default value for the gamma parameter. Compare the number of missclassified observations in the training data for the two models.
5. Compute the model predictions and compare the decision boundaries between the linear and radial SVM using a slice tour. Does the shape match what you expect given the respective kernel function?
XXX somehow using tour with the explore function does not behave as I expect, needs to be checked
6. Repeat but with third class?


```{r}
#| eval: false
#| echo: false
library(mulgar)
library(tourr)
library(tidyverse)
library(MASS)
library(e1071)
library(classifly)
data(bushfires)

bushfires_sub <- dplyr::select(bushfires, log_dist_cfa,
                               log_dist_road,
                               cause) %>%
  filter(cause %in% c("lightning", "arson")) %>%
  mutate(cause = as.factor(cause))

ggplot(bushfires_sub, aes(log_dist_cfa, log_dist_road, color = cause)) +
  geom_point()

bf_lda <- lda(cause ~ ., bushfires_sub)#, prior = c(0.5, 0.5))
bf_lda_b <- as.data.frame(explore(bf_lda, bushfires_sub))
ggplot(filter(bf_lda_b, .BOUNDARY != TRUE)) +
  geom_point(aes(x=log_dist_cfa, y=log_dist_road, colour=cause, shape=.TYPE)) + 
  #scale_color_discrete_divergingx("Zissou 1") +
  scale_shape_manual(values=c(46, 16)) +
  theme_minimal() +
  theme(aspect.ratio = 1, legend.position = "none")

bf_svm <- svm(cause ~ ., bushfires_sub, kernel = "linear",
              probability = TRUE)
bf_svm_b <- as.data.frame(explore(bf_svm, bushfires_sub))
ggplot(filter(bf_svm_b, .BOUNDARY != TRUE)) +
  geom_point(aes(x=log_dist_cfa, y=log_dist_road, colour=cause, shape=.TYPE)) + 
  #scale_color_discrete_divergingx("Zissou 1") +
  scale_shape_manual(values=c(46, 16)) +
  theme_minimal() +
  theme(aspect.ratio = 1, legend.position = "none")

bushfires_sub_2 <- dplyr::select(bushfires,
                                 amaxt90, amaxt180, amaxt720,
                                 log_dist_cfa, log_dist_road,
                                 cause) %>%
  filter(cause %in% c("lightning", "arson")) %>%
  mutate(cause = as.factor(cause))

bf_2_svm <- svm(cause ~ ., data = bushfires_sub_2,
                kernel = "linear", probability = TRUE)

b1_1 <- t(bf_2_svm$SV) %*% bf_2_svm$coefs
# it seems most variables are important, maybe amaxt180
# followed by amaxt90 are less important

bf_2_svm_e <- explore(bf_2_svm, bushfires_sub_2)

symbols <- c(46, 20)
c_pch <- symbols[as.numeric(bf_2_svm_e$.TYPE[!bf_2_svm_e$.BOUNDARY])]
animate_xy(bf_2_svm_e[!bf_2_svm_e$.BOUNDARY,1:5], 
           col=bf_2_svm_e$cause[!bf_2_svm_e$.BOUNDARY],
           pch=c_pch)

set.seed(383)
b_start <- orthonormalise(cbind(b1_1, basis_random(5,1)))
animate_xy(bf_2_svm_e[!bf_2_svm_e$.BOUNDARY,1:5], 
           tour_path = radial_tour(start = b_start,
                                   mvar = c(3,4,5)),
           col=bf_2_svm_e$cause[!bf_2_svm_e$.BOUNDARY],
           pch=c_pch)
# because we use a combination of variables we do not see
# plane turning when rotating out only one of the variables,
# but we can see that combination of the last three is what is
# important

data("sketches_train")
banana_v_cactus <- filter(sketches_train,
                          word %in% c("banana", "cactus"))
bvc_pca <- prcomp(banana_v_cactus[,1:784])
ggscree(bvc_pca, q=25, guide=FALSE) # keeping first 9
bvc_pc <- as.data.frame(bvc_pca$x[,1:9]) 
bvc_pc$word <- droplevels(banana_v_cactus$word)

bvc_pc <- mutate_if(bvc_pc, is.numeric, mulgar:::scale2)

animate_xy(bvc_pc[,1:9], col=bvc_pc$word)



bvc_svm_l <- svm(word ~ ., data = bvc_pc,
                kernel = "linear", probability = TRUE)
sum(predict(bvc_svm_l) != bvc_pc$word)
bvc_svm_r <- svm(word ~ ., data = bvc_pc,
                kernel = "radial", probability = TRUE)
sum(predict(bvc_svm_r) != bvc_pc$word)

bvc_svm_l_e <- explore(bvc_svm_l, bvc_pc)

symbols <- c(46, 20)
c_pch <- symbols[as.numeric(bvc_svm_l_e$.TYPE[!bvc_svm_l_e$.BOUNDARY])]
animate_slice(bvc_svm_l_e[bvc_svm_l_e$.BOUNDARY,1:9], 
           col=bvc_svm_l_e$word[bvc_svm_l_e$.BOUNDARY])
```
